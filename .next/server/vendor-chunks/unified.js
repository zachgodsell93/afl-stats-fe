"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/unified";
exports.ids = ["vendor-chunks/unified"];
exports.modules = {

/***/ "(rsc)/./node_modules/unified/lib/index.js":
/*!*******************************************!*\
  !*** ./node_modules/unified/lib/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   unified: () => (/* binding */ unified)\n/* harmony export */ });\n/* harmony import */ var bail__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! bail */ \"(rsc)/./node_modules/bail/index.js\");\n/* harmony import */ var is_buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-buffer */ \"(rsc)/./node_modules/is-buffer/index.js\");\n/* harmony import */ var is_buffer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(is_buffer__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var extend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! extend */ \"(rsc)/./node_modules/extend/index.js\");\n/* harmony import */ var extend__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(extend__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var is_plain_obj__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! is-plain-obj */ \"(rsc)/./node_modules/unified/node_modules/is-plain-obj/index.js\");\n/* harmony import */ var trough__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! trough */ \"(rsc)/./node_modules/trough/lib/index.js\");\n/* harmony import */ var vfile__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vfile */ \"(rsc)/./node_modules/vfile/lib/index.js\");\n/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('vfile').VFileCompatible} VFileCompatible\n * @typedef {import('vfile').VFileValue} VFileValue\n * @typedef {import('..').Processor} Processor\n * @typedef {import('..').Plugin} Plugin\n * @typedef {import('..').Preset} Preset\n * @typedef {import('..').Pluggable} Pluggable\n * @typedef {import('..').PluggableList} PluggableList\n * @typedef {import('..').Transformer} Transformer\n * @typedef {import('..').Parser} Parser\n * @typedef {import('..').Compiler} Compiler\n * @typedef {import('..').RunCallback} RunCallback\n * @typedef {import('..').ProcessCallback} ProcessCallback\n *\n * @typedef Context\n * @property {Node} tree\n * @property {VFile} file\n */ \n\n\n\n\n\n// Expose a frozen processor.\nconst unified = base().freeze();\nconst own = {}.hasOwnProperty;\n// Function to create the first processor.\n/**\n * @returns {Processor}\n */ function base() {\n    const transformers = (0,trough__WEBPACK_IMPORTED_MODULE_3__.trough)();\n    /** @type {Processor['attachers']} */ const attachers = [];\n    /** @type {Record<string, unknown>} */ let namespace = {};\n    /** @type {boolean|undefined} */ let frozen;\n    let freezeIndex = -1;\n    // Data management.\n    // @ts-expect-error: overloads are handled.\n    processor.data = data;\n    processor.Parser = undefined;\n    processor.Compiler = undefined;\n    // Lock.\n    processor.freeze = freeze;\n    // Plugins.\n    processor.attachers = attachers;\n    // @ts-expect-error: overloads are handled.\n    processor.use = use;\n    // API.\n    processor.parse = parse;\n    processor.stringify = stringify;\n    // @ts-expect-error: overloads are handled.\n    processor.run = run;\n    processor.runSync = runSync;\n    // @ts-expect-error: overloads are handled.\n    processor.process = process;\n    processor.processSync = processSync;\n    // Expose.\n    return processor;\n    // Create a new processor based on the processor in the current scope.\n    /** @type {Processor} */ function processor() {\n        const destination = base();\n        let index = -1;\n        while(++index < attachers.length){\n            destination.use(...attachers[index]);\n        }\n        destination.data(extend__WEBPACK_IMPORTED_MODULE_1___default()(true, {}, namespace));\n        return destination;\n    }\n    /**\n   * @param {string|Record<string, unknown>} [key]\n   * @param {unknown} [value]\n   * @returns {unknown}\n   */ function data(key, value) {\n        if (typeof key === \"string\") {\n            // Set `key`.\n            if (arguments.length === 2) {\n                assertUnfrozen(\"data\", frozen);\n                namespace[key] = value;\n                return processor;\n            }\n            // Get `key`.\n            return own.call(namespace, key) && namespace[key] || null;\n        }\n        // Set space.\n        if (key) {\n            assertUnfrozen(\"data\", frozen);\n            namespace = key;\n            return processor;\n        }\n        // Get space.\n        return namespace;\n    }\n    /** @type {Processor['freeze']} */ function freeze() {\n        if (frozen) {\n            return processor;\n        }\n        while(++freezeIndex < attachers.length){\n            const [attacher, ...options] = attachers[freezeIndex];\n            if (options[0] === false) {\n                continue;\n            }\n            if (options[0] === true) {\n                options[0] = undefined;\n            }\n            /** @type {Transformer|void} */ const transformer = attacher.call(processor, ...options);\n            if (typeof transformer === \"function\") {\n                transformers.use(transformer);\n            }\n        }\n        frozen = true;\n        freezeIndex = Number.POSITIVE_INFINITY;\n        return processor;\n    }\n    /**\n   * @param {Pluggable|null|undefined} [value]\n   * @param {...unknown} options\n   * @returns {Processor}\n   */ function use(value, ...options) {\n        /** @type {Record<string, unknown>|undefined} */ let settings;\n        assertUnfrozen(\"use\", frozen);\n        if (value === null || value === undefined) {\n        // Empty.\n        } else if (typeof value === \"function\") {\n            addPlugin(value, ...options);\n        } else if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                addList(value);\n            } else {\n                addPreset(value);\n            }\n        } else {\n            throw new TypeError(\"Expected usable value, not `\" + value + \"`\");\n        }\n        if (settings) {\n            namespace.settings = Object.assign(namespace.settings || {}, settings);\n        }\n        return processor;\n        /**\n     * @param {import('..').Pluggable<unknown[]>} value\n     * @returns {void}\n     */ function add(value) {\n            if (typeof value === \"function\") {\n                addPlugin(value);\n            } else if (typeof value === \"object\") {\n                if (Array.isArray(value)) {\n                    const [plugin, ...options] = value;\n                    addPlugin(plugin, ...options);\n                } else {\n                    addPreset(value);\n                }\n            } else {\n                throw new TypeError(\"Expected usable value, not `\" + value + \"`\");\n            }\n        }\n        /**\n     * @param {Preset} result\n     * @returns {void}\n     */ function addPreset(result) {\n            addList(result.plugins);\n            if (result.settings) {\n                settings = Object.assign(settings || {}, result.settings);\n            }\n        }\n        /**\n     * @param {PluggableList|null|undefined} [plugins]\n     * @returns {void}\n     */ function addList(plugins) {\n            let index = -1;\n            if (plugins === null || plugins === undefined) {\n            // Empty.\n            } else if (Array.isArray(plugins)) {\n                while(++index < plugins.length){\n                    const thing = plugins[index];\n                    add(thing);\n                }\n            } else {\n                throw new TypeError(\"Expected a list of plugins, not `\" + plugins + \"`\");\n            }\n        }\n        /**\n     * @param {Plugin} plugin\n     * @param {...unknown} [value]\n     * @returns {void}\n     */ function addPlugin(plugin, value) {\n            let index = -1;\n            /** @type {Processor['attachers'][number]|undefined} */ let entry;\n            while(++index < attachers.length){\n                if (attachers[index][0] === plugin) {\n                    entry = attachers[index];\n                    break;\n                }\n            }\n            if (entry) {\n                if ((0,is_plain_obj__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(entry[1]) && (0,is_plain_obj__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(value)) {\n                    value = extend__WEBPACK_IMPORTED_MODULE_1___default()(true, entry[1], value);\n                }\n                entry[1] = value;\n            } else {\n                // @ts-expect-error: fine.\n                attachers.push([\n                    ...arguments\n                ]);\n            }\n        }\n    }\n    /** @type {Processor['parse']} */ function parse(doc) {\n        processor.freeze();\n        const file = vfile(doc);\n        const Parser = processor.Parser;\n        assertParser(\"parse\", Parser);\n        if (newable(Parser, \"parse\")) {\n            // @ts-expect-error: `newable` checks this.\n            return new Parser(String(file), file).parse();\n        }\n        // @ts-expect-error: `newable` checks this.\n        return Parser(String(file), file) // eslint-disable-line new-cap\n        ;\n    }\n    /** @type {Processor['stringify']} */ function stringify(node, doc) {\n        processor.freeze();\n        const file = vfile(doc);\n        const Compiler = processor.Compiler;\n        assertCompiler(\"stringify\", Compiler);\n        assertNode(node);\n        if (newable(Compiler, \"compile\")) {\n            // @ts-expect-error: `newable` checks this.\n            return new Compiler(node, file).compile();\n        }\n        // @ts-expect-error: `newable` checks this.\n        return Compiler(node, file) // eslint-disable-line new-cap\n        ;\n    }\n    /**\n   * @param {Node} node\n   * @param {VFileCompatible|RunCallback} [doc]\n   * @param {RunCallback} [callback]\n   * @returns {Promise<Node>|void}\n   */ function run(node, doc, callback) {\n        assertNode(node);\n        processor.freeze();\n        if (!callback && typeof doc === \"function\") {\n            callback = doc;\n            doc = undefined;\n        }\n        if (!callback) {\n            return new Promise(executor);\n        }\n        executor(null, callback);\n        /**\n     * @param {null|((node: Node) => void)} resolve\n     * @param {(error: Error) => void} reject\n     * @returns {void}\n     */ function executor(resolve, reject) {\n            // @ts-expect-error: `doc` can’t be a callback anymore, we checked.\n            transformers.run(node, vfile(doc), done);\n            /**\n       * @param {Error|null} error\n       * @param {Node} tree\n       * @param {VFile} file\n       * @returns {void}\n       */ function done(error, tree, file) {\n                tree = tree || node;\n                if (error) {\n                    reject(error);\n                } else if (resolve) {\n                    resolve(tree);\n                } else {\n                    // @ts-expect-error: `callback` is defined if `resolve` is not.\n                    callback(null, tree, file);\n                }\n            }\n        }\n    }\n    /** @type {Processor['runSync']} */ function runSync(node, file) {\n        /** @type {Node|undefined} */ let result;\n        /** @type {boolean|undefined} */ let complete;\n        processor.run(node, file, done);\n        assertDone(\"runSync\", \"run\", complete);\n        // @ts-expect-error: we either bailed on an error or have a tree.\n        return result;\n        /**\n     * @param {Error|null} [error]\n     * @param {Node} [tree]\n     * @returns {void}\n     */ function done(error, tree) {\n            (0,bail__WEBPACK_IMPORTED_MODULE_4__.bail)(error);\n            result = tree;\n            complete = true;\n        }\n    }\n    /**\n   * @param {VFileCompatible} doc\n   * @param {ProcessCallback} [callback]\n   * @returns {Promise<VFile>|undefined}\n   */ function process(doc, callback) {\n        processor.freeze();\n        assertParser(\"process\", processor.Parser);\n        assertCompiler(\"process\", processor.Compiler);\n        if (!callback) {\n            return new Promise(executor);\n        }\n        executor(null, callback);\n        /**\n     * @param {null|((file: VFile) => void)} resolve\n     * @param {(error?: Error|null|undefined) => void} reject\n     * @returns {void}\n     */ function executor(resolve, reject) {\n            const file = vfile(doc);\n            processor.run(processor.parse(file), file, (error, tree, file)=>{\n                if (error || !tree || !file) {\n                    done(error);\n                } else {\n                    /** @type {unknown} */ const result = processor.stringify(tree, file);\n                    if (result === undefined || result === null) {\n                    // Empty.\n                    } else if (looksLikeAVFileValue(result)) {\n                        file.value = result;\n                    } else {\n                        file.result = result;\n                    }\n                    done(error, file);\n                }\n            });\n            /**\n       * @param {Error|null|undefined} [error]\n       * @param {VFile|undefined} [file]\n       * @returns {void}\n       */ function done(error, file) {\n                if (error || !file) {\n                    reject(error);\n                } else if (resolve) {\n                    resolve(file);\n                } else {\n                    // @ts-expect-error: `callback` is defined if `resolve` is not.\n                    callback(null, file);\n                }\n            }\n        }\n    }\n    /** @type {Processor['processSync']} */ function processSync(doc) {\n        /** @type {boolean|undefined} */ let complete;\n        processor.freeze();\n        assertParser(\"processSync\", processor.Parser);\n        assertCompiler(\"processSync\", processor.Compiler);\n        const file = vfile(doc);\n        processor.process(file, done);\n        assertDone(\"processSync\", \"process\", complete);\n        return file;\n        /**\n     * @param {Error|null|undefined} [error]\n     * @returns {void}\n     */ function done(error) {\n            complete = true;\n            (0,bail__WEBPACK_IMPORTED_MODULE_4__.bail)(error);\n        }\n    }\n}\n/**\n * Check if `value` is a constructor.\n *\n * @param {unknown} value\n * @param {string} name\n * @returns {boolean}\n */ function newable(value, name) {\n    return typeof value === \"function\" && // Prototypes do exist.\n    // type-coverage:ignore-next-line\n    value.prototype && // A function with keys in its prototype is probably a constructor.\n    // Classes’ prototype methods are not enumerable, so we check if some value\n    // exists in the prototype.\n    // type-coverage:ignore-next-line\n    (keys(value.prototype) || name in value.prototype);\n}\n/**\n * Check if `value` is an object with keys.\n *\n * @param {Record<string, unknown>} value\n * @returns {boolean}\n */ function keys(value) {\n    /** @type {string} */ let key;\n    for(key in value){\n        if (own.call(value, key)) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Assert a parser is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Parser}\n */ function assertParser(name, value) {\n    if (typeof value !== \"function\") {\n        throw new TypeError(\"Cannot `\" + name + \"` without `Parser`\");\n    }\n}\n/**\n * Assert a compiler is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Compiler}\n */ function assertCompiler(name, value) {\n    if (typeof value !== \"function\") {\n        throw new TypeError(\"Cannot `\" + name + \"` without `Compiler`\");\n    }\n}\n/**\n * Assert the processor is not frozen.\n *\n * @param {string} name\n * @param {unknown} frozen\n * @returns {asserts frozen is false}\n */ function assertUnfrozen(name, frozen) {\n    if (frozen) {\n        throw new Error(\"Cannot call `\" + name + \"` on a frozen processor.\\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.\");\n    }\n}\n/**\n * Assert `node` is a unist node.\n *\n * @param {unknown} node\n * @returns {asserts node is Node}\n */ function assertNode(node) {\n    // `isPlainObj` unfortunately uses `any` instead of `unknown`.\n    // type-coverage:ignore-next-line\n    if (!(0,is_plain_obj__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(node) || typeof node.type !== \"string\") {\n        throw new TypeError(\"Expected node, got `\" + node + \"`\");\n    // Fine.\n    }\n}\n/**\n * Assert that `complete` is `true`.\n *\n * @param {string} name\n * @param {string} asyncName\n * @param {unknown} complete\n * @returns {asserts complete is true}\n */ function assertDone(name, asyncName, complete) {\n    if (!complete) {\n        throw new Error(\"`\" + name + \"` finished async. Use `\" + asyncName + \"` instead\");\n    }\n}\n/**\n * @param {VFileCompatible} [value]\n * @returns {VFile}\n */ function vfile(value) {\n    return looksLikeAVFile(value) ? value : new vfile__WEBPACK_IMPORTED_MODULE_5__.VFile(value);\n}\n/**\n * @param {VFileCompatible} [value]\n * @returns {value is VFile}\n */ function looksLikeAVFile(value) {\n    return Boolean(value && typeof value === \"object\" && \"message\" in value && \"messages\" in value);\n}\n/**\n * @param {unknown} [value]\n * @returns {value is VFileValue}\n */ function looksLikeAVFileValue(value) {\n    return typeof value === \"string\" || is_buffer__WEBPACK_IMPORTED_MODULE_0___default()(value);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5pZmllZC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUV3QjtBQUNPO0FBQ0w7QUFDVTtBQUNSO0FBQ0Y7QUFFM0IsNkJBQTZCO0FBQ3RCLE1BQU1NLFVBQVVDLE9BQU9DLE1BQU0sR0FBRTtBQUV0QyxNQUFNQyxNQUFNLENBQUMsRUFBRUMsY0FBYztBQUU3QiwwQ0FBMEM7QUFDMUM7O0NBRUMsR0FDRCxTQUFTSDtJQUNQLE1BQU1JLGVBQWVQLDhDQUFNQTtJQUMzQixtQ0FBbUMsR0FDbkMsTUFBTVEsWUFBWSxFQUFFO0lBQ3BCLG9DQUFvQyxHQUNwQyxJQUFJQyxZQUFZLENBQUM7SUFDakIsOEJBQThCLEdBQzlCLElBQUlDO0lBQ0osSUFBSUMsY0FBYyxDQUFDO0lBRW5CLG1CQUFtQjtJQUNuQiwyQ0FBMkM7SUFDM0NDLFVBQVVDLElBQUksR0FBR0E7SUFDakJELFVBQVVFLE1BQU0sR0FBR0M7SUFDbkJILFVBQVVJLFFBQVEsR0FBR0Q7SUFFckIsUUFBUTtJQUNSSCxVQUFVUixNQUFNLEdBQUdBO0lBRW5CLFdBQVc7SUFDWFEsVUFBVUosU0FBUyxHQUFHQTtJQUN0QiwyQ0FBMkM7SUFDM0NJLFVBQVVLLEdBQUcsR0FBR0E7SUFFaEIsT0FBTztJQUNQTCxVQUFVTSxLQUFLLEdBQUdBO0lBQ2xCTixVQUFVTyxTQUFTLEdBQUdBO0lBQ3RCLDJDQUEyQztJQUMzQ1AsVUFBVVEsR0FBRyxHQUFHQTtJQUNoQlIsVUFBVVMsT0FBTyxHQUFHQTtJQUNwQiwyQ0FBMkM7SUFDM0NULFVBQVVVLE9BQU8sR0FBR0E7SUFDcEJWLFVBQVVXLFdBQVcsR0FBR0E7SUFFeEIsVUFBVTtJQUNWLE9BQU9YO0lBRVAsc0VBQXNFO0lBQ3RFLHNCQUFzQixHQUN0QixTQUFTQTtRQUNQLE1BQU1ZLGNBQWNyQjtRQUNwQixJQUFJc0IsUUFBUSxDQUFDO1FBRWIsTUFBTyxFQUFF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O0FBQ0Y7QUFFQTs7O0NBR0MsR0FDRCxTQUFTeEIsTUFBTTNCLEtBQUs7SUFDbEIsT0FBT29ELGdCQUFnQnBELFNBQVNBLFFBQVEsSUFBSTNCLHdDQUFLQSxDQUFDMkI7QUFDcEQ7QUFFQTs7O0NBR0MsR0FDRCxTQUFTb0QsZ0JBQWdCcEQsS0FBSztJQUM1QixPQUFPcUQsUUFDTHJELFNBQ0UsT0FBT0EsVUFBVSxZQUNqQixhQUFhQSxTQUNiLGNBQWNBO0FBRXBCO0FBRUE7OztDQUdDLEdBQ0QsU0FBUzZDLHFCQUFxQjdDLEtBQUs7SUFDakMsT0FBTyxPQUFPQSxVQUFVLFlBQVkvQixnREFBUUEsQ0FBQytCO0FBQy9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGF4b25vbXkvLi9ub2RlX21vZHVsZXMvdW5pZmllZC9saWIvaW5kZXguanM/MzkzNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ3VuaXN0JykuTm9kZX0gTm9kZVxuICogQHR5cGVkZWYge2ltcG9ydCgndmZpbGUnKS5WRmlsZUNvbXBhdGlibGV9IFZGaWxlQ29tcGF0aWJsZVxuICogQHR5cGVkZWYge2ltcG9ydCgndmZpbGUnKS5WRmlsZVZhbHVlfSBWRmlsZVZhbHVlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLicpLlByb2Nlc3Nvcn0gUHJvY2Vzc29yXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLicpLlBsdWdpbn0gUGx1Z2luXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLicpLlByZXNldH0gUHJlc2V0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLicpLlBsdWdnYWJsZX0gUGx1Z2dhYmxlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLicpLlBsdWdnYWJsZUxpc3R9IFBsdWdnYWJsZUxpc3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uJykuVHJhbnNmb3JtZXJ9IFRyYW5zZm9ybWVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLicpLlBhcnNlcn0gUGFyc2VyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLicpLkNvbXBpbGVyfSBDb21waWxlclxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4nKS5SdW5DYWxsYmFja30gUnVuQ2FsbGJhY2tcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uJykuUHJvY2Vzc0NhbGxiYWNrfSBQcm9jZXNzQ2FsbGJhY2tcbiAqXG4gKiBAdHlwZWRlZiBDb250ZXh0XG4gKiBAcHJvcGVydHkge05vZGV9IHRyZWVcbiAqIEBwcm9wZXJ0eSB7VkZpbGV9IGZpbGVcbiAqL1xuXG5pbXBvcnQge2JhaWx9IGZyb20gJ2JhaWwnXG5pbXBvcnQgaXNCdWZmZXIgZnJvbSAnaXMtYnVmZmVyJ1xuaW1wb3J0IGV4dGVuZCBmcm9tICdleHRlbmQnXG5pbXBvcnQgaXNQbGFpbk9iaiBmcm9tICdpcy1wbGFpbi1vYmonXG5pbXBvcnQge3Ryb3VnaH0gZnJvbSAndHJvdWdoJ1xuaW1wb3J0IHtWRmlsZX0gZnJvbSAndmZpbGUnXG5cbi8vIEV4cG9zZSBhIGZyb3plbiBwcm9jZXNzb3IuXG5leHBvcnQgY29uc3QgdW5pZmllZCA9IGJhc2UoKS5mcmVlemUoKVxuXG5jb25zdCBvd24gPSB7fS5oYXNPd25Qcm9wZXJ0eVxuXG4vLyBGdW5jdGlvbiB0byBjcmVhdGUgdGhlIGZpcnN0IHByb2Nlc3Nvci5cbi8qKlxuICogQHJldHVybnMge1Byb2Nlc3Nvcn1cbiAqL1xuZnVuY3Rpb24gYmFzZSgpIHtcbiAgY29uc3QgdHJhbnNmb3JtZXJzID0gdHJvdWdoKClcbiAgLyoqIEB0eXBlIHtQcm9jZXNzb3JbJ2F0dGFjaGVycyddfSAqL1xuICBjb25zdCBhdHRhY2hlcnMgPSBbXVxuICAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSAqL1xuICBsZXQgbmFtZXNwYWNlID0ge31cbiAgLyoqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH0gKi9cbiAgbGV0IGZyb3plblxuICBsZXQgZnJlZXplSW5kZXggPSAtMVxuXG4gIC8vIERhdGEgbWFuYWdlbWVudC5cbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogb3ZlcmxvYWRzIGFyZSBoYW5kbGVkLlxuICBwcm9jZXNzb3IuZGF0YSA9IGRhdGFcbiAgcHJvY2Vzc29yLlBhcnNlciA9IHVuZGVmaW5lZFxuICBwcm9jZXNzb3IuQ29tcGlsZXIgPSB1bmRlZmluZWRcblxuICAvLyBMb2NrLlxuICBwcm9jZXNzb3IuZnJlZXplID0gZnJlZXplXG5cbiAgLy8gUGx1Z2lucy5cbiAgcHJvY2Vzc29yLmF0dGFjaGVycyA9IGF0dGFjaGVyc1xuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBvdmVybG9hZHMgYXJlIGhhbmRsZWQuXG4gIHByb2Nlc3Nvci51c2UgPSB1c2VcblxuICAvLyBBUEkuXG4gIHByb2Nlc3Nvci5wYXJzZSA9IHBhcnNlXG4gIHByb2Nlc3Nvci5zdHJpbmdpZnkgPSBzdHJpbmdpZnlcbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogb3ZlcmxvYWRzIGFyZSBoYW5kbGVkLlxuICBwcm9jZXNzb3IucnVuID0gcnVuXG4gIHByb2Nlc3Nvci5ydW5TeW5jID0gcnVuU3luY1xuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBvdmVybG9hZHMgYXJlIGhhbmRsZWQuXG4gIHByb2Nlc3Nvci5wcm9jZXNzID0gcHJvY2Vzc1xuICBwcm9jZXNzb3IucHJvY2Vzc1N5bmMgPSBwcm9jZXNzU3luY1xuXG4gIC8vIEV4cG9zZS5cbiAgcmV0dXJuIHByb2Nlc3NvclxuXG4gIC8vIENyZWF0ZSBhIG5ldyBwcm9jZXNzb3IgYmFzZWQgb24gdGhlIHByb2Nlc3NvciBpbiB0aGUgY3VycmVudCBzY29wZS5cbiAgLyoqIEB0eXBlIHtQcm9jZXNzb3J9ICovXG4gIGZ1bmN0aW9uIHByb2Nlc3NvcigpIHtcbiAgICBjb25zdCBkZXN0aW5hdGlvbiA9IGJhc2UoKVxuICAgIGxldCBpbmRleCA9IC0xXG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGF0dGFjaGVycy5sZW5ndGgpIHtcbiAgICAgIGRlc3RpbmF0aW9uLnVzZSguLi5hdHRhY2hlcnNbaW5kZXhdKVxuICAgIH1cblxuICAgIGRlc3RpbmF0aW9uLmRhdGEoZXh0ZW5kKHRydWUsIHt9LCBuYW1lc3BhY2UpKVxuXG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd8UmVjb3JkPHN0cmluZywgdW5rbm93bj59IFtrZXldXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gW3ZhbHVlXVxuICAgKiBAcmV0dXJucyB7dW5rbm93bn1cbiAgICovXG4gIGZ1bmN0aW9uIGRhdGEoa2V5LCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gU2V0IGBrZXlgLlxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgYXNzZXJ0VW5mcm96ZW4oJ2RhdGEnLCBmcm96ZW4pXG4gICAgICAgIG5hbWVzcGFjZVtrZXldID0gdmFsdWVcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NvclxuICAgICAgfVxuXG4gICAgICAvLyBHZXQgYGtleWAuXG4gICAgICByZXR1cm4gKG93bi5jYWxsKG5hbWVzcGFjZSwga2V5KSAmJiBuYW1lc3BhY2Vba2V5XSkgfHwgbnVsbFxuICAgIH1cblxuICAgIC8vIFNldCBzcGFjZS5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBhc3NlcnRVbmZyb3plbignZGF0YScsIGZyb3plbilcbiAgICAgIG5hbWVzcGFjZSA9IGtleVxuICAgICAgcmV0dXJuIHByb2Nlc3NvclxuICAgIH1cblxuICAgIC8vIEdldCBzcGFjZS5cbiAgICByZXR1cm4gbmFtZXNwYWNlXG4gIH1cblxuICAvKiogQHR5cGUge1Byb2Nlc3NvclsnZnJlZXplJ119ICovXG4gIGZ1bmN0aW9uIGZyZWV6ZSgpIHtcbiAgICBpZiAoZnJvemVuKSB7XG4gICAgICByZXR1cm4gcHJvY2Vzc29yXG4gICAgfVxuXG4gICAgd2hpbGUgKCsrZnJlZXplSW5kZXggPCBhdHRhY2hlcnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBbYXR0YWNoZXIsIC4uLm9wdGlvbnNdID0gYXR0YWNoZXJzW2ZyZWV6ZUluZGV4XVxuXG4gICAgICBpZiAob3B0aW9uc1swXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnNbMF0gPT09IHRydWUpIHtcbiAgICAgICAgb3B0aW9uc1swXSA9IHVuZGVmaW5lZFxuICAgICAgfVxuXG4gICAgICAvKiogQHR5cGUge1RyYW5zZm9ybWVyfHZvaWR9ICovXG4gICAgICBjb25zdCB0cmFuc2Zvcm1lciA9IGF0dGFjaGVyLmNhbGwocHJvY2Vzc29yLCAuLi5vcHRpb25zKVxuXG4gICAgICBpZiAodHlwZW9mIHRyYW5zZm9ybWVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRyYW5zZm9ybWVycy51c2UodHJhbnNmb3JtZXIpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnJvemVuID0gdHJ1ZVxuICAgIGZyZWV6ZUluZGV4ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG5cbiAgICByZXR1cm4gcHJvY2Vzc29yXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtQbHVnZ2FibGV8bnVsbHx1bmRlZmluZWR9IFt2YWx1ZV1cbiAgICogQHBhcmFtIHsuLi51bmtub3dufSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9jZXNzb3J9XG4gICAqL1xuICBmdW5jdGlvbiB1c2UodmFsdWUsIC4uLm9wdGlvbnMpIHtcbiAgICAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIHVua25vd24+fHVuZGVmaW5lZH0gKi9cbiAgICBsZXQgc2V0dGluZ3NcblxuICAgIGFzc2VydFVuZnJvemVuKCd1c2UnLCBmcm96ZW4pXG5cbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRW1wdHkuXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFkZFBsdWdpbih2YWx1ZSwgLi4ub3B0aW9ucylcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBhZGRMaXN0KHZhbHVlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkUHJlc2V0KHZhbHVlKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCB1c2FibGUgdmFsdWUsIG5vdCBgJyArIHZhbHVlICsgJ2AnKVxuICAgIH1cblxuICAgIGlmIChzZXR0aW5ncykge1xuICAgICAgbmFtZXNwYWNlLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbihuYW1lc3BhY2Uuc2V0dGluZ3MgfHwge30sIHNldHRpbmdzKVxuICAgIH1cblxuICAgIHJldHVybiBwcm9jZXNzb3JcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLicpLlBsdWdnYWJsZTx1bmtub3duW10+fSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBhZGRQbHVnaW4odmFsdWUpXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgY29uc3QgW3BsdWdpbiwgLi4ub3B0aW9uc10gPSB2YWx1ZVxuICAgICAgICAgIGFkZFBsdWdpbihwbHVnaW4sIC4uLm9wdGlvbnMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkUHJlc2V0KHZhbHVlKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCB1c2FibGUgdmFsdWUsIG5vdCBgJyArIHZhbHVlICsgJ2AnKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UHJlc2V0fSByZXN1bHRcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGRQcmVzZXQocmVzdWx0KSB7XG4gICAgICBhZGRMaXN0KHJlc3VsdC5wbHVnaW5zKVxuXG4gICAgICBpZiAocmVzdWx0LnNldHRpbmdzKSB7XG4gICAgICAgIHNldHRpbmdzID0gT2JqZWN0LmFzc2lnbihzZXR0aW5ncyB8fCB7fSwgcmVzdWx0LnNldHRpbmdzKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UGx1Z2dhYmxlTGlzdHxudWxsfHVuZGVmaW5lZH0gW3BsdWdpbnNdXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkTGlzdChwbHVnaW5zKSB7XG4gICAgICBsZXQgaW5kZXggPSAtMVxuXG4gICAgICBpZiAocGx1Z2lucyA9PT0gbnVsbCB8fCBwbHVnaW5zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gRW1wdHkuXG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocGx1Z2lucykpIHtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBwbHVnaW5zLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IHRoaW5nID0gcGx1Z2luc1tpbmRleF1cbiAgICAgICAgICBhZGQodGhpbmcpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgbGlzdCBvZiBwbHVnaW5zLCBub3QgYCcgKyBwbHVnaW5zICsgJ2AnKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UGx1Z2lufSBwbHVnaW5cbiAgICAgKiBAcGFyYW0gey4uLnVua25vd259IFt2YWx1ZV1cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGRQbHVnaW4ocGx1Z2luLCB2YWx1ZSkge1xuICAgICAgbGV0IGluZGV4ID0gLTFcbiAgICAgIC8qKiBAdHlwZSB7UHJvY2Vzc29yWydhdHRhY2hlcnMnXVtudW1iZXJdfHVuZGVmaW5lZH0gKi9cbiAgICAgIGxldCBlbnRyeVxuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGF0dGFjaGVycy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGF0dGFjaGVyc1tpbmRleF1bMF0gPT09IHBsdWdpbikge1xuICAgICAgICAgIGVudHJ5ID0gYXR0YWNoZXJzW2luZGV4XVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgIGlmIChpc1BsYWluT2JqKGVudHJ5WzFdKSAmJiBpc1BsYWluT2JqKHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlID0gZXh0ZW5kKHRydWUsIGVudHJ5WzFdLCB2YWx1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGVudHJ5WzFdID0gdmFsdWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGZpbmUuXG4gICAgICAgIGF0dGFjaGVycy5wdXNoKFsuLi5hcmd1bWVudHNdKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAdHlwZSB7UHJvY2Vzc29yWydwYXJzZSddfSAqL1xuICBmdW5jdGlvbiBwYXJzZShkb2MpIHtcbiAgICBwcm9jZXNzb3IuZnJlZXplKClcbiAgICBjb25zdCBmaWxlID0gdmZpbGUoZG9jKVxuICAgIGNvbnN0IFBhcnNlciA9IHByb2Nlc3Nvci5QYXJzZXJcbiAgICBhc3NlcnRQYXJzZXIoJ3BhcnNlJywgUGFyc2VyKVxuXG4gICAgaWYgKG5ld2FibGUoUGFyc2VyLCAncGFyc2UnKSkge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogYG5ld2FibGVgIGNoZWNrcyB0aGlzLlxuICAgICAgcmV0dXJuIG5ldyBQYXJzZXIoU3RyaW5nKGZpbGUpLCBmaWxlKS5wYXJzZSgpXG4gICAgfVxuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogYG5ld2FibGVgIGNoZWNrcyB0aGlzLlxuICAgIHJldHVybiBQYXJzZXIoU3RyaW5nKGZpbGUpLCBmaWxlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcbiAgfVxuXG4gIC8qKiBAdHlwZSB7UHJvY2Vzc29yWydzdHJpbmdpZnknXX0gKi9cbiAgZnVuY3Rpb24gc3RyaW5naWZ5KG5vZGUsIGRvYykge1xuICAgIHByb2Nlc3Nvci5mcmVlemUoKVxuICAgIGNvbnN0IGZpbGUgPSB2ZmlsZShkb2MpXG4gICAgY29uc3QgQ29tcGlsZXIgPSBwcm9jZXNzb3IuQ29tcGlsZXJcbiAgICBhc3NlcnRDb21waWxlcignc3RyaW5naWZ5JywgQ29tcGlsZXIpXG4gICAgYXNzZXJ0Tm9kZShub2RlKVxuXG4gICAgaWYgKG5ld2FibGUoQ29tcGlsZXIsICdjb21waWxlJykpIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGBuZXdhYmxlYCBjaGVja3MgdGhpcy5cbiAgICAgIHJldHVybiBuZXcgQ29tcGlsZXIobm9kZSwgZmlsZSkuY29tcGlsZSgpXG4gICAgfVxuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogYG5ld2FibGVgIGNoZWNrcyB0aGlzLlxuICAgIHJldHVybiBDb21waWxlcihub2RlLCBmaWxlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICogQHBhcmFtIHtWRmlsZUNvbXBhdGlibGV8UnVuQ2FsbGJhY2t9IFtkb2NdXG4gICAqIEBwYXJhbSB7UnVuQ2FsbGJhY2t9IFtjYWxsYmFja11cbiAgICogQHJldHVybnMge1Byb21pc2U8Tm9kZT58dm9pZH1cbiAgICovXG4gIGZ1bmN0aW9uIHJ1bihub2RlLCBkb2MsIGNhbGxiYWNrKSB7XG4gICAgYXNzZXJ0Tm9kZShub2RlKVxuICAgIHByb2Nlc3Nvci5mcmVlemUoKVxuXG4gICAgaWYgKCFjYWxsYmFjayAmJiB0eXBlb2YgZG9jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IGRvY1xuICAgICAgZG9jID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGV4ZWN1dG9yKVxuICAgIH1cblxuICAgIGV4ZWN1dG9yKG51bGwsIGNhbGxiYWNrKVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudWxsfCgobm9kZTogTm9kZSkgPT4gdm9pZCl9IHJlc29sdmVcbiAgICAgKiBAcGFyYW0geyhlcnJvcjogRXJyb3IpID0+IHZvaWR9IHJlamVjdFxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogYGRvY2AgY2Fu4oCZdCBiZSBhIGNhbGxiYWNrIGFueW1vcmUsIHdlIGNoZWNrZWQuXG4gICAgICB0cmFuc2Zvcm1lcnMucnVuKG5vZGUsIHZmaWxlKGRvYyksIGRvbmUpXG5cbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnJvclxuICAgICAgICogQHBhcmFtIHtOb2RlfSB0cmVlXG4gICAgICAgKiBAcGFyYW0ge1ZGaWxlfSBmaWxlXG4gICAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gZG9uZShlcnJvciwgdHJlZSwgZmlsZSkge1xuICAgICAgICB0cmVlID0gdHJlZSB8fCBub2RlXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgICAgfSBlbHNlIGlmIChyZXNvbHZlKSB7XG4gICAgICAgICAgcmVzb2x2ZSh0cmVlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGBjYWxsYmFja2AgaXMgZGVmaW5lZCBpZiBgcmVzb2x2ZWAgaXMgbm90LlxuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRyZWUsIGZpbGUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiogQHR5cGUge1Byb2Nlc3NvclsncnVuU3luYyddfSAqL1xuICBmdW5jdGlvbiBydW5TeW5jKG5vZGUsIGZpbGUpIHtcbiAgICAvKiogQHR5cGUge05vZGV8dW5kZWZpbmVkfSAqL1xuICAgIGxldCByZXN1bHRcbiAgICAvKiogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfSAqL1xuICAgIGxldCBjb21wbGV0ZVxuXG4gICAgcHJvY2Vzc29yLnJ1bihub2RlLCBmaWxlLCBkb25lKVxuXG4gICAgYXNzZXJ0RG9uZSgncnVuU3luYycsICdydW4nLCBjb21wbGV0ZSlcblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHdlIGVpdGhlciBiYWlsZWQgb24gYW4gZXJyb3Igb3IgaGF2ZSBhIHRyZWUuXG4gICAgcmV0dXJuIHJlc3VsdFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFcnJvcnxudWxsfSBbZXJyb3JdXG4gICAgICogQHBhcmFtIHtOb2RlfSBbdHJlZV1cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb25lKGVycm9yLCB0cmVlKSB7XG4gICAgICBiYWlsKGVycm9yKVxuICAgICAgcmVzdWx0ID0gdHJlZVxuICAgICAgY29tcGxldGUgPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VkZpbGVDb21wYXRpYmxlfSBkb2NcbiAgICogQHBhcmFtIHtQcm9jZXNzQ2FsbGJhY2t9IFtjYWxsYmFja11cbiAgICogQHJldHVybnMge1Byb21pc2U8VkZpbGU+fHVuZGVmaW5lZH1cbiAgICovXG4gIGZ1bmN0aW9uIHByb2Nlc3MoZG9jLCBjYWxsYmFjaykge1xuICAgIHByb2Nlc3Nvci5mcmVlemUoKVxuICAgIGFzc2VydFBhcnNlcigncHJvY2VzcycsIHByb2Nlc3Nvci5QYXJzZXIpXG4gICAgYXNzZXJ0Q29tcGlsZXIoJ3Byb2Nlc3MnLCBwcm9jZXNzb3IuQ29tcGlsZXIpXG5cbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZXhlY3V0b3IpXG4gICAgfVxuXG4gICAgZXhlY3V0b3IobnVsbCwgY2FsbGJhY2spXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bGx8KChmaWxlOiBWRmlsZSkgPT4gdm9pZCl9IHJlc29sdmVcbiAgICAgKiBAcGFyYW0geyhlcnJvcj86IEVycm9yfG51bGx8dW5kZWZpbmVkKSA9PiB2b2lkfSByZWplY3RcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGNvbnN0IGZpbGUgPSB2ZmlsZShkb2MpXG5cbiAgICAgIHByb2Nlc3Nvci5ydW4ocHJvY2Vzc29yLnBhcnNlKGZpbGUpLCBmaWxlLCAoZXJyb3IsIHRyZWUsIGZpbGUpID0+IHtcbiAgICAgICAgaWYgKGVycm9yIHx8ICF0cmVlIHx8ICFmaWxlKSB7XG4gICAgICAgICAgZG9uZShlcnJvcilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKiogQHR5cGUge3Vua25vd259ICovXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gcHJvY2Vzc29yLnN0cmluZ2lmeSh0cmVlLCBmaWxlKVxuXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkIHx8IHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRW1wdHkuXG4gICAgICAgICAgfSBlbHNlIGlmIChsb29rc0xpa2VBVkZpbGVWYWx1ZShyZXN1bHQpKSB7XG4gICAgICAgICAgICBmaWxlLnZhbHVlID0gcmVzdWx0XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpbGUucmVzdWx0ID0gcmVzdWx0XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZG9uZShlcnJvciwgZmlsZSlcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge0Vycm9yfG51bGx8dW5kZWZpbmVkfSBbZXJyb3JdXG4gICAgICAgKiBAcGFyYW0ge1ZGaWxlfHVuZGVmaW5lZH0gW2ZpbGVdXG4gICAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gZG9uZShlcnJvciwgZmlsZSkge1xuICAgICAgICBpZiAoZXJyb3IgfHwgIWZpbGUpIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpXG4gICAgICAgIH0gZWxzZSBpZiAocmVzb2x2ZSkge1xuICAgICAgICAgIHJlc29sdmUoZmlsZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBgY2FsbGJhY2tgIGlzIGRlZmluZWQgaWYgYHJlc29sdmVgIGlzIG5vdC5cbiAgICAgICAgICBjYWxsYmFjayhudWxsLCBmaWxlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIEB0eXBlIHtQcm9jZXNzb3JbJ3Byb2Nlc3NTeW5jJ119ICovXG4gIGZ1bmN0aW9uIHByb2Nlc3NTeW5jKGRvYykge1xuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9ICovXG4gICAgbGV0IGNvbXBsZXRlXG5cbiAgICBwcm9jZXNzb3IuZnJlZXplKClcbiAgICBhc3NlcnRQYXJzZXIoJ3Byb2Nlc3NTeW5jJywgcHJvY2Vzc29yLlBhcnNlcilcbiAgICBhc3NlcnRDb21waWxlcigncHJvY2Vzc1N5bmMnLCBwcm9jZXNzb3IuQ29tcGlsZXIpXG5cbiAgICBjb25zdCBmaWxlID0gdmZpbGUoZG9jKVxuXG4gICAgcHJvY2Vzc29yLnByb2Nlc3MoZmlsZSwgZG9uZSlcblxuICAgIGFzc2VydERvbmUoJ3Byb2Nlc3NTeW5jJywgJ3Byb2Nlc3MnLCBjb21wbGV0ZSlcblxuICAgIHJldHVybiBmaWxlXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Vycm9yfG51bGx8dW5kZWZpbmVkfSBbZXJyb3JdXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZG9uZShlcnJvcikge1xuICAgICAgY29tcGxldGUgPSB0cnVlXG4gICAgICBiYWlsKGVycm9yKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGB2YWx1ZWAgaXMgYSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge3Vua25vd259IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIG5ld2FibGUodmFsdWUsIG5hbWUpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAvLyBQcm90b3R5cGVzIGRvIGV4aXN0LlxuICAgIC8vIHR5cGUtY292ZXJhZ2U6aWdub3JlLW5leHQtbGluZVxuICAgIHZhbHVlLnByb3RvdHlwZSAmJlxuICAgIC8vIEEgZnVuY3Rpb24gd2l0aCBrZXlzIGluIGl0cyBwcm90b3R5cGUgaXMgcHJvYmFibHkgYSBjb25zdHJ1Y3Rvci5cbiAgICAvLyBDbGFzc2Vz4oCZIHByb3RvdHlwZSBtZXRob2RzIGFyZSBub3QgZW51bWVyYWJsZSwgc28gd2UgY2hlY2sgaWYgc29tZSB2YWx1ZVxuICAgIC8vIGV4aXN0cyBpbiB0aGUgcHJvdG90eXBlLlxuICAgIC8vIHR5cGUtY292ZXJhZ2U6aWdub3JlLW5leHQtbGluZVxuICAgIChrZXlzKHZhbHVlLnByb3RvdHlwZSkgfHwgbmFtZSBpbiB2YWx1ZS5wcm90b3R5cGUpXG4gIClcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCB3aXRoIGtleXMuXG4gKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBrZXlzKHZhbHVlKSB7XG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICBsZXQga2V5XG5cbiAgZm9yIChrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAob3duLmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogQXNzZXJ0IGEgcGFyc2VyIGlzIGF2YWlsYWJsZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHt1bmtub3dufSB2YWx1ZVxuICogQHJldHVybnMge2Fzc2VydHMgdmFsdWUgaXMgUGFyc2VyfVxuICovXG5mdW5jdGlvbiBhc3NlcnRQYXJzZXIobmFtZSwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBgJyArIG5hbWUgKyAnYCB3aXRob3V0IGBQYXJzZXJgJylcbiAgfVxufVxuXG4vKipcbiAqIEFzc2VydCBhIGNvbXBpbGVyIGlzIGF2YWlsYWJsZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHt1bmtub3dufSB2YWx1ZVxuICogQHJldHVybnMge2Fzc2VydHMgdmFsdWUgaXMgQ29tcGlsZXJ9XG4gKi9cbmZ1bmN0aW9uIGFzc2VydENvbXBpbGVyKG5hbWUsIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgYCcgKyBuYW1lICsgJ2Agd2l0aG91dCBgQ29tcGlsZXJgJylcbiAgfVxufVxuXG4vKipcbiAqIEFzc2VydCB0aGUgcHJvY2Vzc29yIGlzIG5vdCBmcm96ZW4uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7dW5rbm93bn0gZnJvemVuXG4gKiBAcmV0dXJucyB7YXNzZXJ0cyBmcm96ZW4gaXMgZmFsc2V9XG4gKi9cbmZ1bmN0aW9uIGFzc2VydFVuZnJvemVuKG5hbWUsIGZyb3plbikge1xuICBpZiAoZnJvemVuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0Nhbm5vdCBjYWxsIGAnICtcbiAgICAgICAgbmFtZSArXG4gICAgICAgICdgIG9uIGEgZnJvemVuIHByb2Nlc3Nvci5cXG5DcmVhdGUgYSBuZXcgcHJvY2Vzc29yIGZpcnN0LCBieSBjYWxsaW5nIGl0OiB1c2UgYHByb2Nlc3NvcigpYCBpbnN0ZWFkIG9mIGBwcm9jZXNzb3JgLidcbiAgICApXG4gIH1cbn1cblxuLyoqXG4gKiBBc3NlcnQgYG5vZGVgIGlzIGEgdW5pc3Qgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge3Vua25vd259IG5vZGVcbiAqIEByZXR1cm5zIHthc3NlcnRzIG5vZGUgaXMgTm9kZX1cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0Tm9kZShub2RlKSB7XG4gIC8vIGBpc1BsYWluT2JqYCB1bmZvcnR1bmF0ZWx5IHVzZXMgYGFueWAgaW5zdGVhZCBvZiBgdW5rbm93bmAuXG4gIC8vIHR5cGUtY292ZXJhZ2U6aWdub3JlLW5leHQtbGluZVxuICBpZiAoIWlzUGxhaW5PYmoobm9kZSkgfHwgdHlwZW9mIG5vZGUudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBub2RlLCBnb3QgYCcgKyBub2RlICsgJ2AnKVxuICAgIC8vIEZpbmUuXG4gIH1cbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCBgY29tcGxldGVgIGlzIGB0cnVlYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGFzeW5jTmFtZVxuICogQHBhcmFtIHt1bmtub3dufSBjb21wbGV0ZVxuICogQHJldHVybnMge2Fzc2VydHMgY29tcGxldGUgaXMgdHJ1ZX1cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0RG9uZShuYW1lLCBhc3luY05hbWUsIGNvbXBsZXRlKSB7XG4gIGlmICghY29tcGxldGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnYCcgKyBuYW1lICsgJ2AgZmluaXNoZWQgYXN5bmMuIFVzZSBgJyArIGFzeW5jTmFtZSArICdgIGluc3RlYWQnXG4gICAgKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtWRmlsZUNvbXBhdGlibGV9IFt2YWx1ZV1cbiAqIEByZXR1cm5zIHtWRmlsZX1cbiAqL1xuZnVuY3Rpb24gdmZpbGUodmFsdWUpIHtcbiAgcmV0dXJuIGxvb2tzTGlrZUFWRmlsZSh2YWx1ZSkgPyB2YWx1ZSA6IG5ldyBWRmlsZSh2YWx1ZSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1ZGaWxlQ29tcGF0aWJsZX0gW3ZhbHVlXVxuICogQHJldHVybnMge3ZhbHVlIGlzIFZGaWxlfVxuICovXG5mdW5jdGlvbiBsb29rc0xpa2VBVkZpbGUodmFsdWUpIHtcbiAgcmV0dXJuIEJvb2xlYW4oXG4gICAgdmFsdWUgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICdtZXNzYWdlJyBpbiB2YWx1ZSAmJlxuICAgICAgJ21lc3NhZ2VzJyBpbiB2YWx1ZVxuICApXG59XG5cbi8qKlxuICogQHBhcmFtIHt1bmtub3dufSBbdmFsdWVdXG4gKiBAcmV0dXJucyB7dmFsdWUgaXMgVkZpbGVWYWx1ZX1cbiAqL1xuZnVuY3Rpb24gbG9va3NMaWtlQVZGaWxlVmFsdWUodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgaXNCdWZmZXIodmFsdWUpXG59XG4iXSwibmFtZXMiOlsiYmFpbCIsImlzQnVmZmVyIiwiZXh0ZW5kIiwiaXNQbGFpbk9iaiIsInRyb3VnaCIsIlZGaWxlIiwidW5pZmllZCIsImJhc2UiLCJmcmVlemUiLCJvd24iLCJoYXNPd25Qcm9wZXJ0eSIsInRyYW5zZm9ybWVycyIsImF0dGFjaGVycyIsIm5hbWVzcGFjZSIsImZyb3plbiIsImZyZWV6ZUluZGV4IiwicHJvY2Vzc29yIiwiZGF0YSIsIlBhcnNlciIsInVuZGVmaW5lZCIsIkNvbXBpbGVyIiwidXNlIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJydW4iLCJydW5TeW5jIiwicHJvY2VzcyIsInByb2Nlc3NTeW5jIiwiZGVzdGluYXRpb24iLCJpbmRleCIsImxlbmd0aCIsImtleSIsInZhbHVlIiwiYXJndW1lbnRzIiwiYXNzZXJ0VW5mcm96ZW4iLCJjYWxsIiwiYXR0YWNoZXIiLCJvcHRpb25zIiwidHJhbnNmb3JtZXIiLCJOdW1iZXIiLCJQT1NJVElWRV9JTkZJTklUWSIsInNldHRpbmdzIiwiYWRkUGx1Z2luIiwiQXJyYXkiLCJpc0FycmF5IiwiYWRkTGlzdCIsImFkZFByZXNldCIsIlR5cGVFcnJvciIsIk9iamVjdCIsImFzc2lnbiIsImFkZCIsInBsdWdpbiIsInJlc3VsdCIsInBsdWdpbnMiLCJ0aGluZyIsImVudHJ5IiwicHVzaCIsImRvYyIsImZpbGUiLCJ2ZmlsZSIsImFzc2VydFBhcnNlciIsIm5ld2FibGUiLCJTdHJpbmciLCJub2RlIiwiYXNzZXJ0Q29tcGlsZXIiLCJhc3NlcnROb2RlIiwiY29tcGlsZSIsImNhbGxiYWNrIiwiUHJvbWlzZSIsImV4ZWN1dG9yIiwicmVzb2x2ZSIsInJlamVjdCIsImRvbmUiLCJlcnJvciIsInRyZWUiLCJjb21wbGV0ZSIsImFzc2VydERvbmUiLCJsb29rc0xpa2VBVkZpbGVWYWx1ZSIsIm5hbWUiLCJwcm90b3R5cGUiLCJrZXlzIiwiRXJyb3IiLCJ0eXBlIiwiYXN5bmNOYW1lIiwibG9va3NMaWtlQVZGaWxlIiwiQm9vbGVhbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/unified/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/unified/node_modules/is-plain-obj/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/unified/node_modules/is-plain-obj/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ isPlainObject)\n/* harmony export */ });\nfunction isPlainObject(value) {\n    if (typeof value !== \"object\" || value === null) {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(value);\n    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5pZmllZC9ub2RlX21vZHVsZXMvaXMtcGxhaW4tb2JqL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZSxTQUFTQSxjQUFjQyxLQUFLO0lBQzFDLElBQUksT0FBT0EsVUFBVSxZQUFZQSxVQUFVLE1BQU07UUFDaEQsT0FBTztJQUNSO0lBRUEsTUFBTUMsWUFBWUMsT0FBT0MsY0FBYyxDQUFDSDtJQUN4QyxPQUFPLENBQUNDLGNBQWMsUUFBUUEsY0FBY0MsT0FBT0QsU0FBUyxJQUFJQyxPQUFPQyxjQUFjLENBQUNGLGVBQWUsSUFBRyxLQUFNLENBQUVHLENBQUFBLE9BQU9DLFdBQVcsSUFBSUwsS0FBSSxLQUFNLENBQUVJLENBQUFBLE9BQU9FLFFBQVEsSUFBSU4sS0FBSTtBQUMxSyIsInNvdXJjZXMiOlsid2VicGFjazovL3RheG9ub215Ly4vbm9kZV9tb2R1bGVzL3VuaWZpZWQvbm9kZV9tb2R1bGVzL2lzLXBsYWluLW9iai9pbmRleC5qcz8zZTc2Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcblx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgdmFsdWUgPT09IG51bGwpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuXHRyZXR1cm4gKHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGUgfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvdHlwZSkgPT09IG51bGwpICYmICEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlKSAmJiAhKFN5bWJvbC5pdGVyYXRvciBpbiB2YWx1ZSk7XG59XG4iXSwibmFtZXMiOlsiaXNQbGFpbk9iamVjdCIsInZhbHVlIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsIml0ZXJhdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/unified/node_modules/is-plain-obj/index.js\n");

/***/ })

};
;