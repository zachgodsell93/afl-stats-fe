"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/uvu";
exports.ids = ["vendor-chunks/uvu"];
exports.modules = {

/***/ "(rsc)/./node_modules/uvu/assert/index.mjs":
/*!*******************************************!*\
  !*** ./node_modules/uvu/assert/index.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Assertion: () => (/* binding */ Assertion),\n/* harmony export */   equal: () => (/* binding */ equal),\n/* harmony export */   fixture: () => (/* binding */ fixture),\n/* harmony export */   instance: () => (/* binding */ instance),\n/* harmony export */   is: () => (/* binding */ is),\n/* harmony export */   match: () => (/* binding */ match),\n/* harmony export */   not: () => (/* binding */ not),\n/* harmony export */   ok: () => (/* binding */ ok),\n/* harmony export */   snapshot: () => (/* binding */ snapshot),\n/* harmony export */   throws: () => (/* binding */ throws),\n/* harmony export */   type: () => (/* binding */ type),\n/* harmony export */   unreachable: () => (/* binding */ unreachable)\n/* harmony export */ });\n/* harmony import */ var dequal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dequal */ \"(rsc)/./node_modules/dequal/dist/index.mjs\");\n/* harmony import */ var uvu_diff__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uvu/diff */ \"(rsc)/./node_modules/uvu/diff/index.mjs\");\n\n\nfunction dedent(str) {\n    str = str.replace(/\\r?\\n/g, \"\\n\");\n    let arr = str.match(/^[ \\t]*(?=\\S)/gm);\n    let i = 0, min = 1 / 0, len = (arr || []).length;\n    for(; i < len; i++)min = Math.min(min, arr[i].length);\n    return len && min ? str.replace(new RegExp(`^[ \\\\t]{${min}}`, \"gm\"), \"\") : str;\n}\nclass Assertion extends Error {\n    constructor(opts = {}){\n        super(opts.message);\n        this.name = \"Assertion\";\n        this.code = \"ERR_ASSERTION\";\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n        }\n        this.details = opts.details || false;\n        this.generated = !!opts.generated;\n        this.operator = opts.operator;\n        this.expects = opts.expects;\n        this.actual = opts.actual;\n    }\n}\nfunction assert(bool, actual, expects, operator, detailer, backup, msg) {\n    if (bool) return;\n    let message = msg || backup;\n    if (msg instanceof Error) throw msg;\n    let details = detailer && detailer(actual, expects);\n    throw new Assertion({\n        actual,\n        expects,\n        operator,\n        message,\n        details,\n        generated: !msg\n    });\n}\nfunction ok(val, msg) {\n    assert(!!val, false, true, \"ok\", false, \"Expected value to be truthy\", msg);\n}\nfunction is(val, exp, msg) {\n    assert(val === exp, val, exp, \"is\", uvu_diff__WEBPACK_IMPORTED_MODULE_1__.compare, \"Expected values to be strictly equal:\", msg);\n}\nfunction equal(val, exp, msg) {\n    assert((0,dequal__WEBPACK_IMPORTED_MODULE_0__.dequal)(val, exp), val, exp, \"equal\", uvu_diff__WEBPACK_IMPORTED_MODULE_1__.compare, \"Expected values to be deeply equal:\", msg);\n}\nfunction unreachable(msg) {\n    assert(false, true, false, \"unreachable\", false, \"Expected not to be reached!\", msg);\n}\nfunction type(val, exp, msg) {\n    let tmp = typeof val;\n    assert(tmp === exp, tmp, exp, \"type\", false, `Expected \"${tmp}\" to be \"${exp}\"`, msg);\n}\nfunction instance(val, exp, msg) {\n    let name = \"`\" + (exp.name || exp.constructor.name) + \"`\";\n    assert(val instanceof exp, val, exp, \"instance\", false, `Expected value to be an instance of ${name}`, msg);\n}\nfunction match(val, exp, msg) {\n    if (typeof exp === \"string\") {\n        assert(val.includes(exp), val, exp, \"match\", false, `Expected value to include \"${exp}\" substring`, msg);\n    } else {\n        assert(exp.test(val), val, exp, \"match\", false, `Expected value to match \\`${String(exp)}\\` pattern`, msg);\n    }\n}\nfunction snapshot(val, exp, msg) {\n    val = dedent(val);\n    exp = dedent(exp);\n    assert(val === exp, val, exp, \"snapshot\", uvu_diff__WEBPACK_IMPORTED_MODULE_1__.lines, \"Expected value to match snapshot:\", msg);\n}\nconst lineNums = (x, y)=>(0,uvu_diff__WEBPACK_IMPORTED_MODULE_1__.lines)(x, y, 1);\nfunction fixture(val, exp, msg) {\n    val = dedent(val);\n    exp = dedent(exp);\n    assert(val === exp, val, exp, \"fixture\", lineNums, \"Expected value to match fixture:\", msg);\n}\nfunction throws(blk, exp, msg) {\n    if (!msg && typeof exp === \"string\") {\n        msg = exp;\n        exp = null;\n    }\n    try {\n        blk();\n        assert(false, false, true, \"throws\", false, \"Expected function to throw\", msg);\n    } catch (err) {\n        if (err instanceof Assertion) throw err;\n        if (typeof exp === \"function\") {\n            assert(exp(err), false, true, \"throws\", false, \"Expected function to throw matching exception\", msg);\n        } else if (exp instanceof RegExp) {\n            assert(exp.test(err.message), false, true, \"throws\", false, `Expected function to throw exception matching \\`${String(exp)}\\` pattern`, msg);\n        }\n    }\n}\n// ---\nfunction not(val, msg) {\n    assert(!val, true, false, \"not\", false, \"Expected value to be falsey\", msg);\n}\nnot.ok = not;\nis.not = function(val, exp, msg) {\n    assert(val !== exp, val, exp, \"is.not\", false, \"Expected values not to be strictly equal\", msg);\n};\nnot.equal = function(val, exp, msg) {\n    assert(!(0,dequal__WEBPACK_IMPORTED_MODULE_0__.dequal)(val, exp), val, exp, \"not.equal\", false, \"Expected values not to be deeply equal\", msg);\n};\nnot.type = function(val, exp, msg) {\n    let tmp = typeof val;\n    assert(tmp !== exp, tmp, exp, \"not.type\", false, `Expected \"${tmp}\" not to be \"${exp}\"`, msg);\n};\nnot.instance = function(val, exp, msg) {\n    let name = \"`\" + (exp.name || exp.constructor.name) + \"`\";\n    assert(!(val instanceof exp), val, exp, \"not.instance\", false, `Expected value not to be an instance of ${name}`, msg);\n};\nnot.snapshot = function(val, exp, msg) {\n    val = dedent(val);\n    exp = dedent(exp);\n    assert(val !== exp, val, exp, \"not.snapshot\", false, \"Expected value not to match snapshot\", msg);\n};\nnot.fixture = function(val, exp, msg) {\n    val = dedent(val);\n    exp = dedent(exp);\n    assert(val !== exp, val, exp, \"not.fixture\", false, \"Expected value not to match fixture\", msg);\n};\nnot.match = function(val, exp, msg) {\n    if (typeof exp === \"string\") {\n        assert(!val.includes(exp), val, exp, \"not.match\", false, `Expected value not to include \"${exp}\" substring`, msg);\n    } else {\n        assert(!exp.test(val), val, exp, \"not.match\", false, `Expected value not to match \\`${String(exp)}\\` pattern`, msg);\n    }\n};\nnot.throws = function(blk, exp, msg) {\n    if (!msg && typeof exp === \"string\") {\n        msg = exp;\n        exp = null;\n    }\n    try {\n        blk();\n    } catch (err) {\n        if (typeof exp === \"function\") {\n            assert(!exp(err), true, false, \"not.throws\", false, \"Expected function not to throw matching exception\", msg);\n        } else if (exp instanceof RegExp) {\n            assert(!exp.test(err.message), true, false, \"not.throws\", false, `Expected function not to throw exception matching \\`${String(exp)}\\` pattern`, msg);\n        } else if (!exp) {\n            assert(false, true, false, \"not.throws\", false, \"Expected function not to throw\", msg);\n        }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdXZ1L2Fzc2VydC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0M7QUFDVTtBQUUxQyxTQUFTRyxPQUFPQyxHQUFHO0lBQ2xCQSxNQUFNQSxJQUFJQyxPQUFPLENBQUMsVUFBVTtJQUMzQixJQUFJQyxNQUFNRixJQUFJRyxLQUFLLENBQUM7SUFDcEIsSUFBSUMsSUFBSSxHQUFHQyxNQUFNLElBQUUsR0FBR0MsTUFBTSxDQUFDSixPQUFLLEVBQUUsRUFBRUssTUFBTTtJQUM1QyxNQUFPSCxJQUFJRSxLQUFLRixJQUFLQyxNQUFNRyxLQUFLSCxHQUFHLENBQUNBLEtBQUtILEdBQUcsQ0FBQ0UsRUFBRSxDQUFDRyxNQUFNO0lBQ3RELE9BQU9ELE9BQU9ELE1BQU1MLElBQUlDLE9BQU8sQ0FBQyxJQUFJUSxPQUFPLENBQUMsUUFBUSxFQUFFSixJQUFJLENBQUMsQ0FBQyxFQUFFLE9BQU8sTUFBTUw7QUFDN0U7QUFFTyxNQUFNVSxrQkFBa0JDO0lBQzlCQyxZQUFZQyxPQUFLLENBQUMsQ0FBQyxDQUFFO1FBQ3BCLEtBQUssQ0FBQ0EsS0FBS0MsT0FBTztRQUNsQixJQUFJLENBQUNDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1FBQ1osSUFBSUwsTUFBTU0saUJBQWlCLEVBQUU7WUFDNUJOLE1BQU1NLGlCQUFpQixDQUFDLElBQUksRUFBRSxJQUFJLENBQUNMLFdBQVc7UUFDL0M7UUFDQSxJQUFJLENBQUNNLE9BQU8sR0FBR0wsS0FBS0ssT0FBTyxJQUFJO1FBQy9CLElBQUksQ0FBQ0MsU0FBUyxHQUFHLENBQUMsQ0FBQ04sS0FBS00sU0FBUztRQUNqQyxJQUFJLENBQUNDLFFBQVEsR0FBR1AsS0FBS08sUUFBUTtRQUM3QixJQUFJLENBQUNDLE9BQU8sR0FBR1IsS0FBS1EsT0FBTztRQUMzQixJQUFJLENBQUNDLE1BQU0sR0FBR1QsS0FBS1MsTUFBTTtJQUMxQjtBQUNEO0FBRUEs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RUFBRUo7SUFDaEg7QUFDRDtBQUVBcUIsSUFBSUgsTUFBTSxHQUFHLFNBQVVDLEdBQUcsRUFBRWYsR0FBRyxFQUFFSixHQUFHO0lBQ25DLElBQUksQ0FBQ0EsT0FBTyxPQUFPSSxRQUFRLFVBQVU7UUFDcENKLE1BQU1JO1FBQUtBLE1BQU07SUFDbEI7SUFFQSxJQUFJO1FBQ0hlO0lBQ0QsRUFBRSxPQUFPQyxLQUFLO1FBQ2IsSUFBSSxPQUFPaEIsUUFBUSxZQUFZO1lBQzlCUixPQUFPLENBQUNRLElBQUlnQixNQUFNLE1BQU0sT0FBTyxjQUFjLE9BQU8scURBQXFEcEI7UUFDMUcsT0FBTyxJQUFJSSxlQUFldEIsUUFBUTtZQUNqQ2MsT0FBTyxDQUFDUSxJQUFJTyxJQUFJLENBQUNTLElBQUlqQyxPQUFPLEdBQUcsTUFBTSxPQUFPLGNBQWMsT0FBTyxDQUFDLG9EQUFvRCxFQUFFeUIsT0FBT1IsS0FBSyxVQUFVLENBQUMsRUFBRUo7UUFDbEosT0FBTyxJQUFJLENBQUNJLEtBQUs7WUFDaEJSLE9BQU8sT0FBTyxNQUFNLE9BQU8sY0FBYyxPQUFPLGtDQUFrQ0k7UUFDbkY7SUFDRDtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGF4b25vbXkvLi9ub2RlX21vZHVsZXMvdXZ1L2Fzc2VydC9pbmRleC5tanM/MjA1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZXF1YWzCoH0gZnJvbSAnZGVxdWFsJztcbmltcG9ydCB7IGNvbXBhcmUsIGxpbmVzIH0gZnJvbSAndXZ1L2RpZmYnO1xuXG5mdW5jdGlvbiBkZWRlbnQoc3RyKSB7XG5cdHN0ciA9IHN0ci5yZXBsYWNlKC9cXHI/XFxuL2csICdcXG4nKTtcbiAgbGV0IGFyciA9IHN0ci5tYXRjaCgvXlsgXFx0XSooPz1cXFMpL2dtKTtcbiAgbGV0IGkgPSAwLCBtaW4gPSAxLzAsIGxlbiA9IChhcnJ8fFtdKS5sZW5ndGg7XG4gIGZvciAoOyBpIDwgbGVuOyBpKyspIG1pbiA9IE1hdGgubWluKG1pbiwgYXJyW2ldLmxlbmd0aCk7XG4gIHJldHVybiBsZW4gJiYgbWluID8gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cChgXlsgXFxcXHRdeyR7bWlufX1gLCAnZ20nKSwgJycpIDogc3RyO1xufVxuXG5leHBvcnQgY2xhc3MgQXNzZXJ0aW9uIGV4dGVuZHMgRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihvcHRzPXt9KSB7XG5cdFx0c3VwZXIob3B0cy5tZXNzYWdlKTtcblx0XHR0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uJztcblx0XHR0aGlzLmNvZGUgPSAnRVJSX0FTU0VSVElPTic7XG5cdFx0aWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG5cdFx0XHRFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcblx0XHR9XG5cdFx0dGhpcy5kZXRhaWxzID0gb3B0cy5kZXRhaWxzIHx8IGZhbHNlO1xuXHRcdHRoaXMuZ2VuZXJhdGVkID0gISFvcHRzLmdlbmVyYXRlZDtcblx0XHR0aGlzLm9wZXJhdG9yID0gb3B0cy5vcGVyYXRvcjtcblx0XHR0aGlzLmV4cGVjdHMgPSBvcHRzLmV4cGVjdHM7XG5cdFx0dGhpcy5hY3R1YWwgPSBvcHRzLmFjdHVhbDtcblx0fVxufVxuXG5mdW5jdGlvbiBhc3NlcnQoYm9vbCwgYWN0dWFsLCBleHBlY3RzLCBvcGVyYXRvciwgZGV0YWlsZXIsIGJhY2t1cCwgbXNnKSB7XG5cdGlmIChib29sKSByZXR1cm47XG5cdGxldCBtZXNzYWdlID0gbXNnIHx8IGJhY2t1cDtcblx0aWYgKG1zZyBpbnN0YW5jZW9mIEVycm9yKSB0aHJvdyBtc2c7XG5cdGxldCBkZXRhaWxzID0gZGV0YWlsZXIgJiYgZGV0YWlsZXIoYWN0dWFsLCBleHBlY3RzKTtcblx0dGhyb3cgbmV3IEFzc2VydGlvbih7IGFjdHVhbCwgZXhwZWN0cywgb3BlcmF0b3IsIG1lc3NhZ2UsIGRldGFpbHMsIGdlbmVyYXRlZDogIW1zZyB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9rKHZhbCwgbXNnKSB7XG5cdGFzc2VydCghIXZhbCwgZmFsc2UsIHRydWUsICdvaycsIGZhbHNlLCAnRXhwZWN0ZWQgdmFsdWUgdG8gYmUgdHJ1dGh5JywgbXNnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzKHZhbCwgZXhwLCBtc2cpIHtcblx0YXNzZXJ0KHZhbCA9PT0gZXhwLCB2YWwsIGV4cCwgJ2lzJywgY29tcGFyZSwgJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBzdHJpY3RseSBlcXVhbDonLCBtc2cpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWwodmFsLCBleHAsIG1zZykge1xuXHRhc3NlcnQoZGVxdWFsKHZhbCwgZXhwKSwgdmFsLCBleHAsICdlcXVhbCcsIGNvbXBhcmUsICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgZGVlcGx5IGVxdWFsOicsIG1zZyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnJlYWNoYWJsZShtc2cpIHtcblx0YXNzZXJ0KGZhbHNlLCB0cnVlLCBmYWxzZSwgJ3VucmVhY2hhYmxlJywgZmFsc2UsICdFeHBlY3RlZCBub3QgdG8gYmUgcmVhY2hlZCEnLCBtc2cpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHlwZSh2YWwsIGV4cCwgbXNnKSB7XG5cdGxldCB0bXAgPSB0eXBlb2YgdmFsO1xuXHRhc3NlcnQodG1wID09PSBleHAsIHRtcCwgZXhwLCAndHlwZScsIGZhbHNlLCBgRXhwZWN0ZWQgXCIke3RtcH1cIiB0byBiZSBcIiR7ZXhwfVwiYCwgbXNnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbmNlKHZhbCwgZXhwLCBtc2cpIHtcblx0bGV0IG5hbWUgPSAnYCcgKyAoZXhwLm5hbWUgfHwgZXhwLmNvbnN0cnVjdG9yLm5hbWUpICsgJ2AnO1xuXHRhc3NlcnQodmFsIGluc3RhbmNlb2YgZXhwLCB2YWwsIGV4cCwgJ2luc3RhbmNlJywgZmFsc2UsIGBFeHBlY3RlZCB2YWx1ZSB0byBiZSBhbiBpbnN0YW5jZSBvZiAke25hbWV9YCwgbXNnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoKHZhbCwgZXhwLCBtc2cpIHtcblx0aWYgKHR5cGVvZiBleHAgPT09ICdzdHJpbmcnKSB7XG5cdFx0YXNzZXJ0KHZhbC5pbmNsdWRlcyhleHApLCB2YWwsIGV4cCwgJ21hdGNoJywgZmFsc2UsIGBFeHBlY3RlZCB2YWx1ZSB0byBpbmNsdWRlIFwiJHtleHB9XCIgc3Vic3RyaW5nYCwgbXNnKTtcblx0fSBlbHNlIHtcblx0XHRhc3NlcnQoZXhwLnRlc3QodmFsKSwgdmFsLCBleHAsICdtYXRjaCcsIGZhbHNlLCBgRXhwZWN0ZWQgdmFsdWUgdG8gbWF0Y2ggXFxgJHtTdHJpbmcoZXhwKX1cXGAgcGF0dGVybmAsIG1zZyk7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNuYXBzaG90KHZhbCwgZXhwLCBtc2cpIHtcblx0dmFsPWRlZGVudCh2YWwpOyBleHA9ZGVkZW50KGV4cCk7XG5cdGFzc2VydCh2YWwgPT09IGV4cCwgdmFsLCBleHAsICdzbmFwc2hvdCcsIGxpbmVzLCAnRXhwZWN0ZWQgdmFsdWUgdG8gbWF0Y2ggc25hcHNob3Q6JywgbXNnKTtcbn1cblxuY29uc3QgbGluZU51bXMgPSAoeCwgeSkgPT4gbGluZXMoeCwgeSwgMSk7XG5leHBvcnQgZnVuY3Rpb24gZml4dHVyZSh2YWwsIGV4cCwgbXNnKSB7XG5cdHZhbD1kZWRlbnQodmFsKTsgZXhwPWRlZGVudChleHApO1xuXHRhc3NlcnQodmFsID09PSBleHAsIHZhbCwgZXhwLCAnZml4dHVyZScsIGxpbmVOdW1zLCAnRXhwZWN0ZWQgdmFsdWUgdG8gbWF0Y2ggZml4dHVyZTonLCBtc2cpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGhyb3dzKGJsaywgZXhwLCBtc2cpIHtcblx0aWYgKCFtc2cgJiYgdHlwZW9mIGV4cCA9PT0gJ3N0cmluZycpIHtcblx0XHRtc2cgPSBleHA7IGV4cCA9IG51bGw7XG5cdH1cblxuXHR0cnkge1xuXHRcdGJsaygpO1xuXHRcdGFzc2VydChmYWxzZSwgZmFsc2UsIHRydWUsICd0aHJvd3MnLCBmYWxzZSwgJ0V4cGVjdGVkIGZ1bmN0aW9uIHRvIHRocm93JywgbXNnKTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0aWYgKGVyciBpbnN0YW5jZW9mIEFzc2VydGlvbikgdGhyb3cgZXJyO1xuXG5cdFx0aWYgKHR5cGVvZiBleHAgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGFzc2VydChleHAoZXJyKSwgZmFsc2UsIHRydWUsICd0aHJvd3MnLCBmYWxzZSwgJ0V4cGVjdGVkIGZ1bmN0aW9uIHRvIHRocm93IG1hdGNoaW5nIGV4Y2VwdGlvbicsIG1zZyk7XG5cdFx0fSBlbHNlIGlmIChleHAgaW5zdGFuY2VvZiBSZWdFeHApIHtcblx0XHRcdGFzc2VydChleHAudGVzdChlcnIubWVzc2FnZSksIGZhbHNlLCB0cnVlLCAndGhyb3dzJywgZmFsc2UsIGBFeHBlY3RlZCBmdW5jdGlvbiB0byB0aHJvdyBleGNlcHRpb24gbWF0Y2hpbmcgXFxgJHtTdHJpbmcoZXhwKX1cXGAgcGF0dGVybmAsIG1zZyk7XG5cdFx0fVxuXHR9XG59XG5cbi8vIC0tLVxuXG5leHBvcnQgZnVuY3Rpb24gbm90KHZhbCwgbXNnKSB7XG5cdGFzc2VydCghdmFsLCB0cnVlLCBmYWxzZSwgJ25vdCcsIGZhbHNlLCAnRXhwZWN0ZWQgdmFsdWUgdG8gYmUgZmFsc2V5JywgbXNnKTtcbn1cblxubm90Lm9rID0gbm90O1xuXG5pcy5ub3QgPSBmdW5jdGlvbiAodmFsLCBleHAsIG1zZykge1xuXHRhc3NlcnQodmFsICE9PSBleHAsIHZhbCwgZXhwLCAnaXMubm90JywgZmFsc2UsICdFeHBlY3RlZCB2YWx1ZXMgbm90IHRvIGJlIHN0cmljdGx5IGVxdWFsJywgbXNnKTtcbn1cblxubm90LmVxdWFsID0gZnVuY3Rpb24gKHZhbCwgZXhwLCBtc2cpIHtcblx0YXNzZXJ0KCFkZXF1YWwodmFsLCBleHApLCB2YWwsIGV4cCwgJ25vdC5lcXVhbCcsIGZhbHNlLCAnRXhwZWN0ZWQgdmFsdWVzIG5vdCB0byBiZSBkZWVwbHkgZXF1YWwnLCBtc2cpO1xufVxuXG5ub3QudHlwZSA9IGZ1bmN0aW9uICh2YWwsIGV4cCwgbXNnKSB7XG5cdGxldCB0bXAgPSB0eXBlb2YgdmFsO1xuXHRhc3NlcnQodG1wICE9PSBleHAsIHRtcCwgZXhwLCAnbm90LnR5cGUnLCBmYWxzZSwgYEV4cGVjdGVkIFwiJHt0bXB9XCIgbm90IHRvIGJlIFwiJHtleHB9XCJgLCBtc2cpO1xufVxuXG5ub3QuaW5zdGFuY2UgPSBmdW5jdGlvbiAodmFsLCBleHAsIG1zZykge1xuXHRsZXQgbmFtZSA9ICdgJyArIChleHAubmFtZSB8fCBleHAuY29uc3RydWN0b3IubmFtZSkgKyAnYCc7XG5cdGFzc2VydCghKHZhbCBpbnN0YW5jZW9mIGV4cCksIHZhbCwgZXhwLCAnbm90Lmluc3RhbmNlJywgZmFsc2UsIGBFeHBlY3RlZCB2YWx1ZSBub3QgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgJHtuYW1lfWAsIG1zZyk7XG59XG5cbm5vdC5zbmFwc2hvdCA9IGZ1bmN0aW9uICh2YWwsIGV4cCwgbXNnKSB7XG5cdHZhbD1kZWRlbnQodmFsKTsgZXhwPWRlZGVudChleHApO1xuXHRhc3NlcnQodmFsICE9PSBleHAsIHZhbCwgZXhwLCAnbm90LnNuYXBzaG90JywgZmFsc2UsICdFeHBlY3RlZCB2YWx1ZSBub3QgdG8gbWF0Y2ggc25hcHNob3QnLCBtc2cpO1xufVxuXG5ub3QuZml4dHVyZSA9IGZ1bmN0aW9uICh2YWwsIGV4cCwgbXNnKSB7XG5cdHZhbD1kZWRlbnQodmFsKTsgZXhwPWRlZGVudChleHApO1xuXHRhc3NlcnQodmFsICE9PSBleHAsIHZhbCwgZXhwLCAnbm90LmZpeHR1cmUnLCBmYWxzZSwgJ0V4cGVjdGVkIHZhbHVlIG5vdCB0byBtYXRjaCBmaXh0dXJlJywgbXNnKTtcbn1cblxubm90Lm1hdGNoID0gZnVuY3Rpb24gKHZhbCwgZXhwLCBtc2cpIHtcblx0aWYgKHR5cGVvZiBleHAgPT09ICdzdHJpbmcnKSB7XG5cdFx0YXNzZXJ0KCF2YWwuaW5jbHVkZXMoZXhwKSwgdmFsLCBleHAsICdub3QubWF0Y2gnLCBmYWxzZSwgYEV4cGVjdGVkIHZhbHVlIG5vdCB0byBpbmNsdWRlIFwiJHtleHB9XCIgc3Vic3RyaW5nYCwgbXNnKTtcblx0fSBlbHNlIHtcblx0XHRhc3NlcnQoIWV4cC50ZXN0KHZhbCksIHZhbCwgZXhwLCAnbm90Lm1hdGNoJywgZmFsc2UsIGBFeHBlY3RlZCB2YWx1ZSBub3QgdG8gbWF0Y2ggXFxgJHtTdHJpbmcoZXhwKX1cXGAgcGF0dGVybmAsIG1zZyk7XG5cdH1cbn1cblxubm90LnRocm93cyA9IGZ1bmN0aW9uIChibGssIGV4cCwgbXNnKSB7XG5cdGlmICghbXNnICYmIHR5cGVvZiBleHAgPT09ICdzdHJpbmcnKSB7XG5cdFx0bXNnID0gZXhwOyBleHAgPSBudWxsO1xuXHR9XG5cblx0dHJ5IHtcblx0XHRibGsoKTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0aWYgKHR5cGVvZiBleHAgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGFzc2VydCghZXhwKGVyciksIHRydWUsIGZhbHNlLCAnbm90LnRocm93cycsIGZhbHNlLCAnRXhwZWN0ZWQgZnVuY3Rpb24gbm90IHRvIHRocm93IG1hdGNoaW5nIGV4Y2VwdGlvbicsIG1zZyk7XG5cdFx0fSBlbHNlIGlmIChleHAgaW5zdGFuY2VvZiBSZWdFeHApIHtcblx0XHRcdGFzc2VydCghZXhwLnRlc3QoZXJyLm1lc3NhZ2UpLCB0cnVlLCBmYWxzZSwgJ25vdC50aHJvd3MnLCBmYWxzZSwgYEV4cGVjdGVkIGZ1bmN0aW9uIG5vdCB0byB0aHJvdyBleGNlcHRpb24gbWF0Y2hpbmcgXFxgJHtTdHJpbmcoZXhwKX1cXGAgcGF0dGVybmAsIG1zZyk7XG5cdFx0fSBlbHNlIGlmICghZXhwKSB7XG5cdFx0XHRhc3NlcnQoZmFsc2UsIHRydWUsIGZhbHNlLCAnbm90LnRocm93cycsIGZhbHNlLCAnRXhwZWN0ZWQgZnVuY3Rpb24gbm90IHRvIHRocm93JywgbXNnKTtcblx0XHR9XG5cdH1cbn1cbiJdLCJuYW1lcyI6WyJkZXF1YWwiLCJjb21wYXJlIiwibGluZXMiLCJkZWRlbnQiLCJzdHIiLCJyZXBsYWNlIiwiYXJyIiwibWF0Y2giLCJpIiwibWluIiwibGVuIiwibGVuZ3RoIiwiTWF0aCIsIlJlZ0V4cCIsIkFzc2VydGlvbiIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJvcHRzIiwibWVzc2FnZSIsIm5hbWUiLCJjb2RlIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJkZXRhaWxzIiwiZ2VuZXJhdGVkIiwib3BlcmF0b3IiLCJleHBlY3RzIiwiYWN0dWFsIiwiYXNzZXJ0IiwiYm9vbCIsImRldGFpbGVyIiwiYmFja3VwIiwibXNnIiwib2siLCJ2YWwiLCJpcyIsImV4cCIsImVxdWFsIiwidW5yZWFjaGFibGUiLCJ0eXBlIiwidG1wIiwiaW5zdGFuY2UiLCJpbmNsdWRlcyIsInRlc3QiLCJTdHJpbmciLCJzbmFwc2hvdCIsImxpbmVOdW1zIiwieCIsInkiLCJmaXh0dXJlIiwidGhyb3dzIiwiYmxrIiwiZXJyIiwibm90Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/uvu/assert/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/uvu/diff/index.mjs":
/*!*****************************************!*\
  !*** ./node_modules/uvu/diff/index.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrays: () => (/* binding */ arrays),\n/* harmony export */   chars: () => (/* binding */ chars),\n/* harmony export */   circular: () => (/* binding */ circular),\n/* harmony export */   compare: () => (/* binding */ compare),\n/* harmony export */   direct: () => (/* binding */ direct),\n/* harmony export */   lines: () => (/* binding */ lines),\n/* harmony export */   sort: () => (/* binding */ sort),\n/* harmony export */   stringify: () => (/* binding */ stringify)\n/* harmony export */ });\n/* harmony import */ var kleur__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! kleur */ \"(rsc)/./node_modules/kleur/index.mjs\");\n/* harmony import */ var diff__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diff */ \"(rsc)/./node_modules/uvu/node_modules/diff/lib/index.mjs\");\n\n\nconst colors = {\n    \"--\": kleur__WEBPACK_IMPORTED_MODULE_0__[\"default\"].red,\n    \"\\xb7\\xb7\": kleur__WEBPACK_IMPORTED_MODULE_0__[\"default\"].grey,\n    \"++\": kleur__WEBPACK_IMPORTED_MODULE_0__[\"default\"].green\n};\nconst TITLE = kleur__WEBPACK_IMPORTED_MODULE_0__[\"default\"].dim().italic;\nconst TAB = kleur__WEBPACK_IMPORTED_MODULE_0__[\"default\"].dim(\"→\"), SPACE = kleur__WEBPACK_IMPORTED_MODULE_0__[\"default\"].dim(\"\\xb7\"), NL = kleur__WEBPACK_IMPORTED_MODULE_0__[\"default\"].dim(\"↵\");\nconst LOG = (sym, str)=>colors[sym](sym + PRETTY(str)) + \"\\n\";\nconst LINE = (num, x)=>kleur__WEBPACK_IMPORTED_MODULE_0__[\"default\"].dim(\"L\" + String(num).padStart(x, \"0\") + \" \");\nconst PRETTY = (str)=>str.replace(/[ ]/g, SPACE).replace(/\\t/g, TAB).replace(/(\\r?\\n)/g, NL);\nfunction line(obj, prev, pad) {\n    let char = obj.removed ? \"--\" : obj.added ? \"++\" : \"\\xb7\\xb7\";\n    let arr = obj.value.replace(/\\r?\\n$/, \"\").split(\"\\n\");\n    let i = 0, tmp, out = \"\";\n    if (obj.added) out += colors[char]().underline(TITLE(\"Expected:\")) + \"\\n\";\n    else if (obj.removed) out += colors[char]().underline(TITLE(\"Actual:\")) + \"\\n\";\n    for(; i < arr.length; i++){\n        tmp = arr[i];\n        if (tmp != null) {\n            if (prev) out += LINE(prev + i, pad);\n            out += LOG(char, tmp || \"\\n\");\n        }\n    }\n    return out;\n}\n// TODO: want better diffing\n//~> complex items bail outright\nfunction arrays(input, expect) {\n    let arr = diff__WEBPACK_IMPORTED_MODULE_1__.diffArrays(input, expect);\n    let i = 0, j = 0, k = 0, tmp, val, char, isObj, str;\n    let out = LOG(\"\\xb7\\xb7\", \"[\");\n    for(; i < arr.length; i++){\n        char = (tmp = arr[i]).removed ? \"--\" : tmp.added ? \"++\" : \"\\xb7\\xb7\";\n        if (tmp.added) {\n            out += colors[char]().underline(TITLE(\"Expected:\")) + \"\\n\";\n        } else if (tmp.removed) {\n            out += colors[char]().underline(TITLE(\"Actual:\")) + \"\\n\";\n        }\n        for(j = 0; j < tmp.value.length; j++){\n            isObj = tmp.value[j] && typeof tmp.value[j] === \"object\";\n            val = stringify(tmp.value[j]).split(/\\r?\\n/g);\n            for(k = 0; k < val.length;){\n                str = \"  \" + val[k++] + (isObj ? \"\" : \",\");\n                if (isObj && k === val.length && j + 1 < tmp.value.length) str += \",\";\n                out += LOG(char, str);\n            }\n        }\n    }\n    return out + LOG(\"\\xb7\\xb7\", \"]\");\n}\nfunction lines(input, expect, linenum = 0) {\n    let i = 0, tmp, output = \"\";\n    let arr = diff__WEBPACK_IMPORTED_MODULE_1__.diffLines(input, expect);\n    let pad = String(expect.split(/\\r?\\n/g).length - linenum).length;\n    for(; i < arr.length; i++){\n        output += line(tmp = arr[i], linenum, pad);\n        if (linenum && !tmp.removed) linenum += tmp.count;\n    }\n    return output;\n}\nfunction chars(input, expect) {\n    let arr = diff__WEBPACK_IMPORTED_MODULE_1__.diffChars(input, expect);\n    let i = 0, output = \"\", tmp;\n    let l1 = input.length;\n    let l2 = expect.length;\n    let p1 = PRETTY(input);\n    let p2 = PRETTY(expect);\n    tmp = arr[i];\n    if (l1 === l2) {\n    // no length offsets\n    } else if (tmp.removed && arr[i + 1]) {\n        let del = tmp.count - arr[i + 1].count;\n        if (del == 0) {\n        // wash~\n        } else if (del > 0) {\n            expect = \" \".repeat(del) + expect;\n            p2 = \" \".repeat(del) + p2;\n            l2 += del;\n        } else if (del < 0) {\n            input = \" \".repeat(-del) + input;\n            p1 = \" \".repeat(-del) + p1;\n            l1 += -del;\n        }\n    }\n    output += direct(p1, p2, l1, l2);\n    if (l1 === l2) {\n        for(tmp = \"  \"; i < l1; i++){\n            tmp += input[i] === expect[i] ? \" \" : \"^\";\n        }\n    } else {\n        for(tmp = \"  \"; i < arr.length; i++){\n            tmp += (arr[i].added || arr[i].removed ? \"^\" : \" \").repeat(Math.max(arr[i].count, 0));\n            if (i + 1 < arr.length && (arr[i].added && arr[i + 1].removed || arr[i].removed && arr[i + 1].added)) {\n                arr[i + 1].count -= arr[i].count;\n            }\n        }\n    }\n    return output + kleur__WEBPACK_IMPORTED_MODULE_0__[\"default\"].red(tmp);\n}\nfunction direct(input, expect, lenA = String(input).length, lenB = String(expect).length) {\n    let gutter = 4;\n    let lenC = Math.max(lenA, lenB);\n    let typeA = typeof input, typeB = typeof expect;\n    if (typeA !== typeB) {\n        gutter = 2;\n        let delA = gutter + lenC - lenA;\n        let delB = gutter + lenC - lenB;\n        input += \" \".repeat(delA) + kleur__WEBPACK_IMPORTED_MODULE_0__[\"default\"].dim(`[${typeA}]`);\n        expect += \" \".repeat(delB) + kleur__WEBPACK_IMPORTED_MODULE_0__[\"default\"].dim(`[${typeB}]`);\n        lenA += delA + typeA.length + 2;\n        lenB += delB + typeB.length + 2;\n        lenC = Math.max(lenA, lenB);\n    }\n    let output = colors[\"++\"](\"++\" + expect + \" \".repeat(gutter + lenC - lenB) + TITLE(\"(Expected)\")) + \"\\n\";\n    return output + colors[\"--\"](\"--\" + input + \" \".repeat(gutter + lenC - lenA) + TITLE(\"(Actual)\")) + \"\\n\";\n}\nfunction sort(input, expect) {\n    var k, i = 0, tmp, isArr = Array.isArray(input);\n    var keys = [], out = isArr ? Array(input.length) : {};\n    if (isArr) {\n        for(i = 0; i < out.length; i++){\n            tmp = input[i];\n            if (!tmp || typeof tmp !== \"object\") out[i] = tmp;\n            else out[i] = sort(tmp, expect[i]); // might not be right\n        }\n    } else {\n        for(k in expect)keys.push(k);\n        for(; i < keys.length; i++){\n            if (Object.prototype.hasOwnProperty.call(input, k = keys[i])) {\n                if (!(tmp = input[k]) || typeof tmp !== \"object\") out[k] = tmp;\n                else out[k] = sort(tmp, expect[k]);\n            }\n        }\n        for(k in input){\n            if (!out.hasOwnProperty(k)) {\n                out[k] = input[k]; // expect didnt have\n            }\n        }\n    }\n    return out;\n}\nfunction circular() {\n    var cache = new Set;\n    return function print(key, val) {\n        if (val === void 0) return \"[__VOID__]\";\n        if (typeof val === \"number\" && val !== val) return \"[__NAN__]\";\n        if (typeof val === \"bigint\") return val.toString();\n        if (!val || typeof val !== \"object\") return val;\n        if (cache.has(val)) return \"[Circular]\";\n        cache.add(val);\n        return val;\n    };\n}\nfunction stringify(input) {\n    return JSON.stringify(input, circular(), 2).replace(/\"\\[__NAN__\\]\"/g, \"NaN\").replace(/\"\\[__VOID__\\]\"/g, \"undefined\");\n}\nfunction compare(input, expect) {\n    if (Array.isArray(expect) && Array.isArray(input)) return arrays(input, expect);\n    if (expect instanceof RegExp) return chars(\"\" + input, \"\" + expect);\n    let isA = input && typeof input == \"object\";\n    let isB = expect && typeof expect == \"object\";\n    if (isA && isB) input = sort(input, expect);\n    if (isB) expect = stringify(expect);\n    if (isA) input = stringify(input);\n    if (expect && typeof expect == \"object\") {\n        input = stringify(sort(input, expect));\n        expect = stringify(expect);\n    }\n    isA = typeof input == \"string\";\n    isB = typeof expect == \"string\";\n    if (isA && /\\r?\\n/.test(input)) return lines(input, \"\" + expect);\n    if (isB && /\\r?\\n/.test(expect)) return lines(\"\" + input, expect);\n    if (isA && isB) return chars(input, expect);\n    return direct(input, expect);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFTO0lBQ25DLElBQUlzRCxNQUFNckQsVUFBVSxPQUFPQSxVQUFVO0lBRXJDLElBQUlvRCxPQUFPQyxLQUFLdEQsUUFBUWdDLEtBQUtoQyxPQUFPQztJQUNwQyxJQUFJcUQsS0FBS3JELFNBQVNNLFVBQVVOO0lBQzVCLElBQUlvRCxLQUFLckQsUUFBUU8sVUFBVVA7SUFFM0IsSUFBSUMsVUFBVSxPQUFPQSxVQUFVLFVBQVU7UUFDeENELFFBQVFPLFVBQVV5QixLQUFLaEMsT0FBT0M7UUFDOUJBLFNBQVNNLFVBQVVOO0lBQ3BCO0lBRUFvRCxNQUFNLE9BQU9yRCxTQUFTO0lBQ3RCc0QsTUFBTSxPQUFPckQsVUFBVTtJQUV2QixJQUFJb0QsT0FBTyxRQUFRRSxJQUFJLENBQUN2RCxRQUFRLE9BQU9RLE1BQU1SLE9BQU8sS0FBR0M7SUFDdkQsSUFBSXFELE9BQU8sUUFBUUMsSUFBSSxDQUFDdEQsU0FBUyxPQUFPTyxNQUFNLEtBQUdSLE9BQU9DO0lBQ3hELElBQUlvRCxPQUFPQyxLQUFLLE9BQU96QyxNQUFNYixPQUFPQztJQUVwQyxPQUFPb0IsT0FBT3JCLE9BQU9DO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGF4b25vbXkvLi9ub2RlX21vZHVsZXMvdXZ1L2RpZmYvaW5kZXgubWpzP2I5MDYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGtsZXVyIGZyb20gJ2tsZXVyJztcbmltcG9ydCAqIGFzIGRpZmYgZnJvbSAnZGlmZic7XG5cbmNvbnN0IGNvbG9ycyA9IHtcblx0Jy0tJzoga2xldXIucmVkLFxuXHQnwrfCtyc6IGtsZXVyLmdyZXksXG5cdCcrKyc6IGtsZXVyLmdyZWVuLFxufTtcblxuY29uc3QgVElUTEUgPSBrbGV1ci5kaW0oKS5pdGFsaWM7XG5jb25zdCBUQUI9a2xldXIuZGltKCfihpInKSwgU1BBQ0U9a2xldXIuZGltKCfCtycpLCBOTD1rbGV1ci5kaW0oJ+KGtScpO1xuY29uc3QgTE9HID0gKHN5bSwgc3RyKSA9PiBjb2xvcnNbc3ltXShzeW0gKyBQUkVUVFkoc3RyKSkgKyAnXFxuJztcbmNvbnN0IExJTkUgPSAobnVtLCB4KSA9PiBrbGV1ci5kaW0oJ0wnICsgU3RyaW5nKG51bSkucGFkU3RhcnQoeCwgJzAnKSArICcgJyk7XG5jb25zdCBQUkVUVFkgPSBzdHIgPT4gc3RyLnJlcGxhY2UoL1sgXS9nLCBTUEFDRSkucmVwbGFjZSgvXFx0L2csIFRBQikucmVwbGFjZSgvKFxccj9cXG4pL2csIE5MKTtcblxuZnVuY3Rpb24gbGluZShvYmosIHByZXYsIHBhZCkge1xuXHRsZXQgY2hhciA9IG9iai5yZW1vdmVkID8gJy0tJyA6IG9iai5hZGRlZCA/ICcrKycgOiAnwrfCtyc7XG5cdGxldCBhcnIgPSBvYmoudmFsdWUucmVwbGFjZSgvXFxyP1xcbiQvLCAnJykuc3BsaXQoJ1xcbicpO1xuXHRsZXQgaT0wLCB0bXAsIG91dD0nJztcblxuXHRpZiAob2JqLmFkZGVkKSBvdXQgKz0gY29sb3JzW2NoYXJdKCkudW5kZXJsaW5lKFRJVExFKCdFeHBlY3RlZDonKSkgKyAnXFxuJztcblx0ZWxzZSBpZiAob2JqLnJlbW92ZWQpIG91dCArPSBjb2xvcnNbY2hhcl0oKS51bmRlcmxpbmUoVElUTEUoJ0FjdHVhbDonKSkgKyAnXFxuJztcblxuXHRmb3IgKDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuXHRcdHRtcCA9IGFycltpXTtcblx0XHRpZiAodG1wICE9IG51bGwpIHtcblx0XHRcdGlmIChwcmV2KSBvdXQgKz0gTElORShwcmV2ICsgaSwgcGFkKTtcblx0XHRcdG91dCArPSBMT0coY2hhciwgdG1wIHx8ICdcXG4nKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gb3V0O1xufVxuXG4vLyBUT0RPOiB3YW50IGJldHRlciBkaWZmaW5nXG4vL34+IGNvbXBsZXggaXRlbXMgYmFpbCBvdXRyaWdodFxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5cyhpbnB1dCwgZXhwZWN0KSB7XG5cdGxldCBhcnIgPSBkaWZmLmRpZmZBcnJheXMoaW5wdXQsIGV4cGVjdCk7XG5cdGxldCBpPTAsIGo9MCwgaz0wLCB0bXAsIHZhbCwgY2hhciwgaXNPYmosIHN0cjtcblx0bGV0IG91dCA9IExPRygnwrfCtycsICdbJyk7XG5cblx0Zm9yICg7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcblx0XHRjaGFyID0gKHRtcCA9IGFycltpXSkucmVtb3ZlZCA/ICctLScgOiB0bXAuYWRkZWQgPyAnKysnIDogJ8K3wrcnO1xuXG5cdFx0aWYgKHRtcC5hZGRlZCkge1xuXHRcdFx0b3V0ICs9IGNvbG9yc1tjaGFyXSgpLnVuZGVybGluZShUSVRMRSgnRXhwZWN0ZWQ6JykpICsgJ1xcbic7XG5cdFx0fSBlbHNlIGlmICh0bXAucmVtb3ZlZCkge1xuXHRcdFx0b3V0ICs9IGNvbG9yc1tjaGFyXSgpLnVuZGVybGluZShUSVRMRSgnQWN0dWFsOicpKSArICdcXG4nO1xuXHRcdH1cblxuXHRcdGZvciAoaj0wOyBqIDwgdG1wLnZhbHVlLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRpc09iaiA9ICh0bXAudmFsdWVbal0gJiYgdHlwZW9mIHRtcC52YWx1ZVtqXSA9PT0gJ29iamVjdCcpO1xuXHRcdFx0dmFsID0gc3RyaW5naWZ5KHRtcC52YWx1ZVtqXSkuc3BsaXQoL1xccj9cXG4vZyk7XG5cdFx0XHRmb3IgKGs9MDsgayA8IHZhbC5sZW5ndGg7KSB7XG5cdFx0XHRcdHN0ciA9ICcgICcgKyB2YWxbaysrXSArIChpc09iaiA/ICcnIDogJywnKTtcblx0XHRcdFx0aWYgKGlzT2JqICYmIGsgPT09IHZhbC5sZW5ndGggJiYgKGogKyAxKSA8IHRtcC52YWx1ZS5sZW5ndGgpIHN0ciArPSAnLCc7XG5cdFx0XHRcdG91dCArPSBMT0coY2hhciwgc3RyKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gb3V0ICsgTE9HKCfCt8K3JywgJ10nKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpbmVzKGlucHV0LCBleHBlY3QsIGxpbmVudW0gPSAwKSB7XG5cdGxldCBpPTAsIHRtcCwgb3V0cHV0PScnO1xuXHRsZXQgYXJyID0gZGlmZi5kaWZmTGluZXMoaW5wdXQsIGV4cGVjdCk7XG5cdGxldCBwYWQgPSBTdHJpbmcoZXhwZWN0LnNwbGl0KC9cXHI/XFxuL2cpLmxlbmd0aCAtIGxpbmVudW0pLmxlbmd0aDtcblxuXHRmb3IgKDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuXHRcdG91dHB1dCArPSBsaW5lKHRtcCA9IGFycltpXSwgbGluZW51bSwgcGFkKTtcblx0XHRpZiAobGluZW51bSAmJiAhdG1wLnJlbW92ZWQpIGxpbmVudW0gKz0gdG1wLmNvdW50O1xuXHR9XG5cblx0cmV0dXJuIG91dHB1dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoYXJzKGlucHV0LCBleHBlY3QpIHtcblx0bGV0IGFyciA9IGRpZmYuZGlmZkNoYXJzKGlucHV0LCBleHBlY3QpO1xuXHRsZXQgaT0wLCBvdXRwdXQ9JycsIHRtcDtcblxuXHRsZXQgbDEgPSBpbnB1dC5sZW5ndGg7XG5cdGxldCBsMiA9IGV4cGVjdC5sZW5ndGg7XG5cblx0bGV0IHAxID0gUFJFVFRZKGlucHV0KTtcblx0bGV0IHAyID0gUFJFVFRZKGV4cGVjdCk7XG5cblx0dG1wID0gYXJyW2ldO1xuXG5cdGlmIChsMSA9PT0gbDIpIHtcblx0XHQvLyBubyBsZW5ndGggb2Zmc2V0c1xuXHR9IGVsc2UgaWYgKHRtcC5yZW1vdmVkICYmIGFycltpICsgMV0pIHtcblx0XHRsZXQgZGVsID0gdG1wLmNvdW50IC0gYXJyW2kgKyAxXS5jb3VudDtcblx0XHRpZiAoZGVsID09IDApIHtcblx0XHRcdC8vIHdhc2h+XG5cdFx0fSBlbHNlIGlmIChkZWwgPiAwKSB7XG5cdFx0XHRleHBlY3QgPSAnICcucmVwZWF0KGRlbCkgKyBleHBlY3Q7XG5cdFx0XHRwMiA9ICcgJy5yZXBlYXQoZGVsKSArIHAyO1xuXHRcdFx0bDIgKz0gZGVsO1xuXHRcdH0gZWxzZSBpZiAoZGVsIDwgMCkge1xuXHRcdFx0aW5wdXQgPSAnICcucmVwZWF0KC1kZWwpICsgaW5wdXQ7XG5cdFx0XHRwMSA9ICcgJy5yZXBlYXQoLWRlbCkgKyBwMTtcblx0XHRcdGwxICs9IC1kZWw7XG5cdFx0fVxuXHR9XG5cblx0b3V0cHV0ICs9IGRpcmVjdChwMSwgcDIsIGwxLCBsMik7XG5cblx0aWYgKGwxID09PSBsMikge1xuXHRcdGZvciAodG1wPScgICc7IGkgPCBsMTsgaSsrKSB7XG5cdFx0XHR0bXAgKz0gaW5wdXRbaV0gPT09IGV4cGVjdFtpXSA/ICcgJyA6ICdeJztcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Zm9yICh0bXA9JyAgJzsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuXHRcdFx0dG1wICs9ICgoYXJyW2ldLmFkZGVkIHx8IGFycltpXS5yZW1vdmVkKSA/ICdeJyA6ICcgJykucmVwZWF0KE1hdGgubWF4KGFycltpXS5jb3VudCwgMCkpO1xuXHRcdFx0aWYgKGkgKyAxIDwgYXJyLmxlbmd0aCAmJiAoKGFycltpXS5hZGRlZCAmJiBhcnJbaSsxXS5yZW1vdmVkKSB8fCAoYXJyW2ldLnJlbW92ZWQgJiYgYXJyW2krMV0uYWRkZWQpKSkge1xuXHRcdFx0XHRhcnJbaSArIDFdLmNvdW50IC09IGFycltpXS5jb3VudDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gb3V0cHV0ICsga2xldXIucmVkKHRtcCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXJlY3QoaW5wdXQsIGV4cGVjdCwgbGVuQSA9IFN0cmluZyhpbnB1dCkubGVuZ3RoLCBsZW5CID0gU3RyaW5nKGV4cGVjdCkubGVuZ3RoKSB7XG5cdGxldCBndXR0ZXIgPSA0O1xuXHRsZXQgbGVuQyA9IE1hdGgubWF4KGxlbkEsIGxlbkIpO1xuXHRsZXQgdHlwZUE9dHlwZW9mIGlucHV0LCB0eXBlQj10eXBlb2YgZXhwZWN0O1xuXG5cdGlmICh0eXBlQSAhPT0gdHlwZUIpIHtcblx0XHRndXR0ZXIgPSAyO1xuXG5cdFx0bGV0IGRlbEEgPSBndXR0ZXIgKyBsZW5DIC0gbGVuQTtcblx0XHRsZXQgZGVsQiA9IGd1dHRlciArIGxlbkMgLSBsZW5CO1xuXG5cdFx0aW5wdXQgKz0gJyAnLnJlcGVhdChkZWxBKSArIGtsZXVyLmRpbShgWyR7dHlwZUF9XWApO1xuXHRcdGV4cGVjdCArPSAnICcucmVwZWF0KGRlbEIpICsga2xldXIuZGltKGBbJHt0eXBlQn1dYCk7XG5cblx0XHRsZW5BICs9IGRlbEEgKyB0eXBlQS5sZW5ndGggKyAyO1xuXHRcdGxlbkIgKz0gZGVsQiArIHR5cGVCLmxlbmd0aCArIDI7XG5cdFx0bGVuQyA9IE1hdGgubWF4KGxlbkEsIGxlbkIpO1xuXHR9XG5cblx0bGV0IG91dHB1dCA9IGNvbG9yc1snKysnXSgnKysnICsgZXhwZWN0ICsgJyAnLnJlcGVhdChndXR0ZXIgKyBsZW5DIC0gbGVuQikgKyBUSVRMRSgnKEV4cGVjdGVkKScpKSArICdcXG4nO1xuXHRyZXR1cm4gb3V0cHV0ICsgY29sb3JzWyctLSddKCctLScgKyBpbnB1dCArICcgJy5yZXBlYXQoZ3V0dGVyICsgbGVuQyAtIGxlbkEpICsgVElUTEUoJyhBY3R1YWwpJykpICsgJ1xcbic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzb3J0KGlucHV0LCBleHBlY3QpIHtcblx0dmFyIGssIGk9MCwgdG1wLCBpc0FyciA9IEFycmF5LmlzQXJyYXkoaW5wdXQpO1xuXHR2YXIga2V5cz1bXSwgb3V0PWlzQXJyID8gQXJyYXkoaW5wdXQubGVuZ3RoKSA6IHt9O1xuXG5cdGlmIChpc0Fycikge1xuXHRcdGZvciAoaT0wOyBpIDwgb3V0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0bXAgPSBpbnB1dFtpXTtcblx0XHRcdGlmICghdG1wIHx8IHR5cGVvZiB0bXAgIT09ICdvYmplY3QnKSBvdXRbaV0gPSB0bXA7XG5cdFx0XHRlbHNlIG91dFtpXSA9IHNvcnQodG1wLCBleHBlY3RbaV0pOyAvLyBtaWdodCBub3QgYmUgcmlnaHRcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Zm9yIChrIGluIGV4cGVjdClcblx0XHRcdGtleXMucHVzaChrKTtcblxuXHRcdGZvciAoOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpbnB1dCwgayA9IGtleXNbaV0pKSB7XG5cdFx0XHRcdGlmICghKHRtcCA9IGlucHV0W2tdKSB8fCB0eXBlb2YgdG1wICE9PSAnb2JqZWN0Jykgb3V0W2tdID0gdG1wO1xuXHRcdFx0XHRlbHNlIG91dFtrXSA9IHNvcnQodG1wLCBleHBlY3Rba10pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoayBpbiBpbnB1dCkge1xuXHRcdFx0aWYgKCFvdXQuaGFzT3duUHJvcGVydHkoaykpIHtcblx0XHRcdFx0b3V0W2tdID0gaW5wdXRba107IC8vIGV4cGVjdCBkaWRudCBoYXZlXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG91dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNpcmN1bGFyKCkge1xuXHR2YXIgY2FjaGUgPSBuZXcgU2V0O1xuXHRyZXR1cm4gZnVuY3Rpb24gcHJpbnQoa2V5LCB2YWwpIHtcblx0XHRpZiAodmFsID09PSB2b2lkIDApIHJldHVybiAnW19fVk9JRF9fXSc7XG5cdFx0aWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmIHZhbCAhPT0gdmFsKSByZXR1cm4gJ1tfX05BTl9fXSc7XG5cdFx0aWYgKHR5cGVvZiB2YWwgPT09ICdiaWdpbnQnKSByZXR1cm4gdmFsLnRvU3RyaW5nKCk7XG5cdFx0aWYgKCF2YWwgfHwgdHlwZW9mIHZhbCAhPT0gJ29iamVjdCcpIHJldHVybiB2YWw7XG5cdFx0aWYgKGNhY2hlLmhhcyh2YWwpKSByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuXHRcdGNhY2hlLmFkZCh2YWwpOyByZXR1cm4gdmFsO1xuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnkoaW5wdXQpIHtcblx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KGlucHV0LCBjaXJjdWxhcigpLCAyKS5yZXBsYWNlKC9cIlxcW19fTkFOX19cXF1cIi9nLCAnTmFOJykucmVwbGFjZSgvXCJcXFtfX1ZPSURfX1xcXVwiL2csICd1bmRlZmluZWQnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmUoaW5wdXQsIGV4cGVjdCkge1xuXHRpZiAoQXJyYXkuaXNBcnJheShleHBlY3QpICYmIEFycmF5LmlzQXJyYXkoaW5wdXQpKSByZXR1cm4gYXJyYXlzKGlucHV0LCBleHBlY3QpO1xuXHRpZiAoZXhwZWN0IGluc3RhbmNlb2YgUmVnRXhwKSByZXR1cm4gY2hhcnMoJycraW5wdXQsICcnK2V4cGVjdCk7XG5cblx0bGV0IGlzQSA9IGlucHV0ICYmIHR5cGVvZiBpbnB1dCA9PSAnb2JqZWN0Jztcblx0bGV0IGlzQiA9IGV4cGVjdCAmJiB0eXBlb2YgZXhwZWN0ID09ICdvYmplY3QnO1xuXG5cdGlmIChpc0EgJiYgaXNCKSBpbnB1dCA9IHNvcnQoaW5wdXQsIGV4cGVjdCk7XG5cdGlmIChpc0IpIGV4cGVjdCA9IHN0cmluZ2lmeShleHBlY3QpO1xuXHRpZiAoaXNBKSBpbnB1dCA9IHN0cmluZ2lmeShpbnB1dCk7XG5cblx0aWYgKGV4cGVjdCAmJiB0eXBlb2YgZXhwZWN0ID09ICdvYmplY3QnKSB7XG5cdFx0aW5wdXQgPSBzdHJpbmdpZnkoc29ydChpbnB1dCwgZXhwZWN0KSk7XG5cdFx0ZXhwZWN0ID0gc3RyaW5naWZ5KGV4cGVjdCk7XG5cdH1cblxuXHRpc0EgPSB0eXBlb2YgaW5wdXQgPT0gJ3N0cmluZyc7XG5cdGlzQiA9IHR5cGVvZiBleHBlY3QgPT0gJ3N0cmluZyc7XG5cblx0aWYgKGlzQSAmJiAvXFxyP1xcbi8udGVzdChpbnB1dCkpIHJldHVybiBsaW5lcyhpbnB1dCwgJycrZXhwZWN0KTtcblx0aWYgKGlzQiAmJiAvXFxyP1xcbi8udGVzdChleHBlY3QpKSByZXR1cm4gbGluZXMoJycraW5wdXQsIGV4cGVjdCk7XG5cdGlmIChpc0EgJiYgaXNCKSByZXR1cm4gY2hhcnMoaW5wdXQsIGV4cGVjdCk7XG5cblx0cmV0dXJuIGRpcmVjdChpbnB1dCwgZXhwZWN0KTtcbn1cbiJdLCJuYW1lcyI6WyJrbGV1ciIsImRpZmYiLCJjb2xvcnMiLCJyZWQiLCJncmV5IiwiZ3JlZW4iLCJUSVRMRSIsImRpbSIsIml0YWxpYyIsIlRBQiIsIlNQQUNFIiwiTkwiLCJMT0ciLCJzeW0iLCJzdHIiLCJQUkVUVFkiLCJMSU5FIiwibnVtIiwieCIsIlN0cmluZyIsInBhZFN0YXJ0IiwicmVwbGFjZSIsImxpbmUiLCJvYmoiLCJwcmV2IiwicGFkIiwiY2hhciIsInJlbW92ZWQiLCJhZGRlZCIsImFyciIsInZhbHVlIiwic3BsaXQiLCJpIiwidG1wIiwib3V0IiwidW5kZXJsaW5lIiwibGVuZ3RoIiwiYXJyYXlzIiwiaW5wdXQiLCJleHBlY3QiLCJkaWZmQXJyYXlzIiwiaiIsImsiLCJ2YWwiLCJpc09iaiIsInN0cmluZ2lmeSIsImxpbmVzIiwibGluZW51bSIsIm91dHB1dCIsImRpZmZMaW5lcyIsImNvdW50IiwiY2hhcnMiLCJkaWZmQ2hhcnMiLCJsMSIsImwyIiwicDEiLCJwMiIsImRlbCIsInJlcGVhdCIsImRpcmVjdCIsIk1hdGgiLCJtYXgiLCJsZW5BIiwibGVuQiIsImd1dHRlciIsImxlbkMiLCJ0eXBlQSIsInR5cGVCIiwiZGVsQSIsImRlbEIiLCJzb3J0IiwiaXNBcnIiLCJBcnJheSIsImlzQXJyYXkiLCJrZXlzIiwicHVzaCIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImNpcmN1bGFyIiwiY2FjaGUiLCJTZXQiLCJwcmludCIsImtleSIsInRvU3RyaW5nIiwiaGFzIiwiYWRkIiwiSlNPTiIsImNvbXBhcmUiLCJSZWdFeHAiLCJpc0EiLCJpc0IiLCJ0ZXN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/uvu/diff/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/uvu/node_modules/diff/lib/index.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/uvu/node_modules/diff/lib/index.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Diff: () => (/* binding */ Diff),\n/* harmony export */   applyPatch: () => (/* binding */ applyPatch),\n/* harmony export */   applyPatches: () => (/* binding */ applyPatches),\n/* harmony export */   canonicalize: () => (/* binding */ canonicalize),\n/* harmony export */   convertChangesToDMP: () => (/* binding */ convertChangesToDMP),\n/* harmony export */   convertChangesToXML: () => (/* binding */ convertChangesToXML),\n/* harmony export */   createPatch: () => (/* binding */ createPatch),\n/* harmony export */   createTwoFilesPatch: () => (/* binding */ createTwoFilesPatch),\n/* harmony export */   diffArrays: () => (/* binding */ diffArrays),\n/* harmony export */   diffChars: () => (/* binding */ diffChars),\n/* harmony export */   diffCss: () => (/* binding */ diffCss),\n/* harmony export */   diffJson: () => (/* binding */ diffJson),\n/* harmony export */   diffLines: () => (/* binding */ diffLines),\n/* harmony export */   diffSentences: () => (/* binding */ diffSentences),\n/* harmony export */   diffTrimmedLines: () => (/* binding */ diffTrimmedLines),\n/* harmony export */   diffWords: () => (/* binding */ diffWords),\n/* harmony export */   diffWordsWithSpace: () => (/* binding */ diffWordsWithSpace),\n/* harmony export */   formatPatch: () => (/* binding */ formatPatch),\n/* harmony export */   merge: () => (/* binding */ merge),\n/* harmony export */   parsePatch: () => (/* binding */ parsePatch),\n/* harmony export */   reversePatch: () => (/* binding */ reversePatch),\n/* harmony export */   structuredPatch: () => (/* binding */ structuredPatch)\n/* harmony export */ });\nfunction Diff() {}\nDiff.prototype = {\n    diff: function diff(oldString, newString) {\n        var _options$timeout;\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var callback = options.callback;\n        if (typeof options === \"function\") {\n            callback = options;\n            options = {};\n        }\n        this.options = options;\n        var self = this;\n        function done(value) {\n            if (callback) {\n                setTimeout(function() {\n                    callback(undefined, value);\n                }, 0);\n                return true;\n            } else {\n                return value;\n            }\n        } // Allow subclasses to massage the input prior to running\n        oldString = this.castInput(oldString);\n        newString = this.castInput(newString);\n        oldString = this.removeEmpty(this.tokenize(oldString));\n        newString = this.removeEmpty(this.tokenize(newString));\n        var newLen = newString.length, oldLen = oldString.length;\n        var editLength = 1;\n        var maxEditLength = newLen + oldLen;\n        if (options.maxEditLength) {\n            maxEditLength = Math.min(maxEditLength, options.maxEditLength);\n        }\n        var maxExecutionTime = (_options$timeout = options.timeout) !== null && _options$timeout !== void 0 ? _options$timeout : Infinity;\n        var abortAfterTimestamp = Date.now() + maxExecutionTime;\n        var bestPath = [\n            {\n                oldPos: -1,\n                lastComponent: undefined\n            }\n        ]; // Seed editLength = 0, i.e. the content starts with the same values\n        var newPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n        if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n            // Identity per the equality and tokenizer\n            return done([\n                {\n                    value: this.join(newString),\n                    count: newString.length\n                }\n            ]);\n        } // Once we hit the right edge of the edit graph on some diagonal k, we can\n        // definitely reach the end of the edit graph in no more than k edits, so\n        // there's no point in considering any moves to diagonal k+1 any more (from\n        // which we're guaranteed to need at least k+1 more edits).\n        // Similarly, once we've reached the bottom of the edit graph, there's no\n        // point considering moves to lower diagonals.\n        // We record this fact by setting minDiagonalToConsider and\n        // maxDiagonalToConsider to some finite value once we've hit the edge of\n        // the edit graph.\n        // This optimization is not faithful to the original algorithm presented in\n        // Myers's paper, which instead pointlessly extends D-paths off the end of\n        // the edit graph - see page 7 of Myers's paper which notes this point\n        // explicitly and illustrates it with a diagram. This has major performance\n        // implications for some common scenarios. For instance, to compute a diff\n        // where the new text simply appends d characters on the end of the\n        // original text of length n, the true Myers algorithm will take O(n+d^2)\n        // time while this optimization needs only O(n+d) time.\n        var minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity; // Main worker method. checks all permutations of a given edit length for acceptance.\n        function execEditLength() {\n            for(var diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2){\n                var basePath = void 0;\n                var removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];\n                if (removePath) {\n                    // No one else is going to attempt to use this value, clear it\n                    bestPath[diagonalPath - 1] = undefined;\n                }\n                var canAdd = false;\n                if (addPath) {\n                    // what newPos will be after we do an insertion:\n                    var addPathNewPos = addPath.oldPos - diagonalPath;\n                    canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;\n                }\n                var canRemove = removePath && removePath.oldPos + 1 < oldLen;\n                if (!canAdd && !canRemove) {\n                    // If this path is a terminal then prune\n                    bestPath[diagonalPath] = undefined;\n                    continue;\n                } // Select the diagonal that we want to branch from. We select the prior\n                // path whose position in the old string is the farthest from the origin\n                // and does not pass the bounds of the diff graph\n                // TODO: Remove the `+ 1` here to make behavior match Myers algorithm\n                //       and prefer to order removals before insertions.\n                if (!canRemove || canAdd && removePath.oldPos + 1 < addPath.oldPos) {\n                    basePath = self.addToPath(addPath, true, undefined, 0);\n                } else {\n                    basePath = self.addToPath(removePath, undefined, true, 1);\n                }\n                newPos = self.extractCommon(basePath, newString, oldString, diagonalPath);\n                if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n                    // If we have hit the end of both strings, then we are done\n                    return done(buildValues(self, basePath.lastComponent, newString, oldString, self.useLongestToken));\n                } else {\n                    bestPath[diagonalPath] = basePath;\n                    if (basePath.oldPos + 1 >= oldLen) {\n                        maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);\n                    }\n                    if (newPos + 1 >= newLen) {\n                        minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);\n                    }\n                }\n            }\n            editLength++;\n        } // Performs the length of edit iteration. Is a bit fugly as this has to support the\n        // sync and async mode which is never fun. Loops over execEditLength until a value\n        // is produced, or until the edit length exceeds options.maxEditLength (if given),\n        // in which case it will return undefined.\n        if (callback) {\n            (function exec() {\n                setTimeout(function() {\n                    if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {\n                        return callback();\n                    }\n                    if (!execEditLength()) {\n                        exec();\n                    }\n                }, 0);\n            })();\n        } else {\n            while(editLength <= maxEditLength && Date.now() <= abortAfterTimestamp){\n                var ret = execEditLength();\n                if (ret) {\n                    return ret;\n                }\n            }\n        }\n    },\n    addToPath: function addToPath(path, added, removed, oldPosInc) {\n        var last = path.lastComponent;\n        if (last && last.added === added && last.removed === removed) {\n            return {\n                oldPos: path.oldPos + oldPosInc,\n                lastComponent: {\n                    count: last.count + 1,\n                    added: added,\n                    removed: removed,\n                    previousComponent: last.previousComponent\n                }\n            };\n        } else {\n            return {\n                oldPos: path.oldPos + oldPosInc,\n                lastComponent: {\n                    count: 1,\n                    added: added,\n                    removed: removed,\n                    previousComponent: last\n                }\n            };\n        }\n    },\n    extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n        var newLen = newString.length, oldLen = oldString.length, oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;\n        while(newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])){\n            newPos++;\n            oldPos++;\n            commonCount++;\n        }\n        if (commonCount) {\n            basePath.lastComponent = {\n                count: commonCount,\n                previousComponent: basePath.lastComponent\n            };\n        }\n        basePath.oldPos = oldPos;\n        return newPos;\n    },\n    equals: function equals(left, right) {\n        if (this.options.comparator) {\n            return this.options.comparator(left, right);\n        } else {\n            return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n        }\n    },\n    removeEmpty: function removeEmpty(array) {\n        var ret = [];\n        for(var i = 0; i < array.length; i++){\n            if (array[i]) {\n                ret.push(array[i]);\n            }\n        }\n        return ret;\n    },\n    castInput: function castInput(value) {\n        return value;\n    },\n    tokenize: function tokenize(value) {\n        return value.split(\"\");\n    },\n    join: function join(chars) {\n        return chars.join(\"\");\n    }\n};\nfunction buildValues(diff, lastComponent, newString, oldString, useLongestToken) {\n    // First we convert our linked list of components in reverse order to an\n    // array in the right order:\n    var components = [];\n    var nextComponent;\n    while(lastComponent){\n        components.push(lastComponent);\n        nextComponent = lastComponent.previousComponent;\n        delete lastComponent.previousComponent;\n        lastComponent = nextComponent;\n    }\n    components.reverse();\n    var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0;\n    for(; componentPos < componentLen; componentPos++){\n        var component = components[componentPos];\n        if (!component.removed) {\n            if (!component.added && useLongestToken) {\n                var value = newString.slice(newPos, newPos + component.count);\n                value = value.map(function(value, i) {\n                    var oldValue = oldString[oldPos + i];\n                    return oldValue.length > value.length ? oldValue : value;\n                });\n                component.value = diff.join(value);\n            } else {\n                component.value = diff.join(newString.slice(newPos, newPos + component.count));\n            }\n            newPos += component.count; // Common case\n            if (!component.added) {\n                oldPos += component.count;\n            }\n        } else {\n            component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n            oldPos += component.count; // Reverse add and remove so removes are output first to match common convention\n            // The diffing algorithm is tied to add then remove output and this is the simplest\n            // route to get the desired output with minimal overhead.\n            if (componentPos && components[componentPos - 1].added) {\n                var tmp = components[componentPos - 1];\n                components[componentPos - 1] = components[componentPos];\n                components[componentPos] = tmp;\n            }\n        }\n    } // Special case handle for when one terminal is ignored (i.e. whitespace).\n    // For this case we merge the terminal into the prior string and drop the change.\n    // This is only available for string mode.\n    var finalComponent = components[componentLen - 1];\n    if (componentLen > 1 && typeof finalComponent.value === \"string\" && (finalComponent.added || finalComponent.removed) && diff.equals(\"\", finalComponent.value)) {\n        components[componentLen - 2].value += finalComponent.value;\n        components.pop();\n    }\n    return components;\n}\nvar characterDiff = new Diff();\nfunction diffChars(oldStr, newStr, options) {\n    return characterDiff.diff(oldStr, newStr, options);\n}\nfunction generateOptions(options, defaults) {\n    if (typeof options === \"function\") {\n        defaults.callback = options;\n    } else if (options) {\n        for(var name in options){\n            /* istanbul ignore else */ if (options.hasOwnProperty(name)) {\n                defaults[name] = options[name];\n            }\n        }\n    }\n    return defaults;\n}\n//\n// Ranges and exceptions:\n// Latin-1 Supplement, 0080–00FF\n//  - U+00D7  × Multiplication sign\n//  - U+00F7  ÷ Division sign\n// Latin Extended-A, 0100–017F\n// Latin Extended-B, 0180–024F\n// IPA Extensions, 0250–02AF\n// Spacing Modifier Letters, 02B0–02FF\n//  - U+02C7  ˇ &#711;  Caron\n//  - U+02D8  ˘ &#728;  Breve\n//  - U+02D9  ˙ &#729;  Dot Above\n//  - U+02DA  ˚ &#730;  Ring Above\n//  - U+02DB  ˛ &#731;  Ogonek\n//  - U+02DC  ˜ &#732;  Small Tilde\n//  - U+02DD  ˝ &#733;  Double Acute Accent\n// Latin Extended Additional, 1E00–1EFF\nvar extendedWordChars = /^[A-Za-z\\xC0-\\u02C6\\u02C8-\\u02D7\\u02DE-\\u02FF\\u1E00-\\u1EFF]+$/;\nvar reWhitespace = /\\S/;\nvar wordDiff = new Diff();\nwordDiff.equals = function(left, right) {\n    if (this.options.ignoreCase) {\n        left = left.toLowerCase();\n        right = right.toLowerCase();\n    }\n    return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);\n};\nwordDiff.tokenize = function(value) {\n    // All whitespace symbols except newline group into one token, each newline - in separate token\n    var tokens = value.split(/([^\\S\\r\\n]+|[()[\\]{}'\"\\r\\n]|\\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\n    for(var i = 0; i < tokens.length - 1; i++){\n        // If we have an empty string in the next field and we have only word chars before and after, merge\n        if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {\n            tokens[i] += tokens[i + 2];\n            tokens.splice(i + 1, 2);\n            i--;\n        }\n    }\n    return tokens;\n};\nfunction diffWords(oldStr, newStr, options) {\n    options = generateOptions(options, {\n        ignoreWhitespace: true\n    });\n    return wordDiff.diff(oldStr, newStr, options);\n}\nfunction diffWordsWithSpace(oldStr, newStr, options) {\n    return wordDiff.diff(oldStr, newStr, options);\n}\nvar lineDiff = new Diff();\nlineDiff.tokenize = function(value) {\n    if (this.options.stripTrailingCr) {\n        // remove one \\r before \\n to match GNU diff's --strip-trailing-cr behavior\n        value = value.replace(/\\r\\n/g, \"\\n\");\n    }\n    var retLines = [], linesAndNewlines = value.split(/(\\n|\\r\\n)/); // Ignore the final empty token that occurs if the string ends with a new line\n    if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n        linesAndNewlines.pop();\n    } // Merge the content and line separators into single tokens\n    for(var i = 0; i < linesAndNewlines.length; i++){\n        var line = linesAndNewlines[i];\n        if (i % 2 && !this.options.newlineIsToken) {\n            retLines[retLines.length - 1] += line;\n        } else {\n            if (this.options.ignoreWhitespace) {\n                line = line.trim();\n            }\n            retLines.push(line);\n        }\n    }\n    return retLines;\n};\nfunction diffLines(oldStr, newStr, callback) {\n    return lineDiff.diff(oldStr, newStr, callback);\n}\nfunction diffTrimmedLines(oldStr, newStr, callback) {\n    var options = generateOptions(callback, {\n        ignoreWhitespace: true\n    });\n    return lineDiff.diff(oldStr, newStr, options);\n}\nvar sentenceDiff = new Diff();\nsentenceDiff.tokenize = function(value) {\n    return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n};\nfunction diffSentences(oldStr, newStr, callback) {\n    return sentenceDiff.diff(oldStr, newStr, callback);\n}\nvar cssDiff = new Diff();\ncssDiff.tokenize = function(value) {\n    return value.split(/([{}:;,]|\\s+)/);\n};\nfunction diffCss(oldStr, newStr, callback) {\n    return cssDiff.diff(oldStr, newStr, callback);\n}\nfunction _typeof(obj) {\n    \"@babel/helpers - typeof\";\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function(obj) {\n            return typeof obj;\n        };\n    } else {\n        _typeof = function(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n    }\n    return _typeof(obj);\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        });\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nvar objectPrototypeToString = Object.prototype.toString;\nvar jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\njsonDiff.useLongestToken = true;\njsonDiff.tokenize = lineDiff.tokenize;\njsonDiff.castInput = function(value) {\n    var _this$options = this.options, undefinedReplacement = _this$options.undefinedReplacement, _this$options$stringi = _this$options.stringifyReplacer, stringifyReplacer = _this$options$stringi === void 0 ? function(k, v) {\n        return typeof v === \"undefined\" ? undefinedReplacement : v;\n    } : _this$options$stringi;\n    return typeof value === \"string\" ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, \"  \");\n};\njsonDiff.equals = function(left, right) {\n    return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, \"$1\"), right.replace(/,([\\r\\n])/g, \"$1\"));\n};\nfunction diffJson(oldObj, newObj, options) {\n    return jsonDiff.diff(oldObj, newObj, options);\n} // This function handles the presence of circular references by bailing out when encountering an\n// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\nfunction canonicalize(obj, stack, replacementStack, replacer, key) {\n    stack = stack || [];\n    replacementStack = replacementStack || [];\n    if (replacer) {\n        obj = replacer(key, obj);\n    }\n    var i;\n    for(i = 0; i < stack.length; i += 1){\n        if (stack[i] === obj) {\n            return replacementStack[i];\n        }\n    }\n    var canonicalizedObj;\n    if (\"[object Array]\" === objectPrototypeToString.call(obj)) {\n        stack.push(obj);\n        canonicalizedObj = new Array(obj.length);\n        replacementStack.push(canonicalizedObj);\n        for(i = 0; i < obj.length; i += 1){\n            canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n        }\n        stack.pop();\n        replacementStack.pop();\n        return canonicalizedObj;\n    }\n    if (obj && obj.toJSON) {\n        obj = obj.toJSON();\n    }\n    if (_typeof(obj) === \"object\" && obj !== null) {\n        stack.push(obj);\n        canonicalizedObj = {};\n        replacementStack.push(canonicalizedObj);\n        var sortedKeys = [], _key;\n        for(_key in obj){\n            /* istanbul ignore else */ if (obj.hasOwnProperty(_key)) {\n                sortedKeys.push(_key);\n            }\n        }\n        sortedKeys.sort();\n        for(i = 0; i < sortedKeys.length; i += 1){\n            _key = sortedKeys[i];\n            canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\n        }\n        stack.pop();\n        replacementStack.pop();\n    } else {\n        canonicalizedObj = obj;\n    }\n    return canonicalizedObj;\n}\nvar arrayDiff = new Diff();\narrayDiff.tokenize = function(value) {\n    return value.slice();\n};\narrayDiff.join = arrayDiff.removeEmpty = function(value) {\n    return value;\n};\nfunction diffArrays(oldArr, newArr, callback) {\n    return arrayDiff.diff(oldArr, newArr, callback);\n}\nfunction parsePatch(uniDiff) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/), delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [], list = [], i = 0;\n    function parseIndex() {\n        var index = {};\n        list.push(index); // Parse diff metadata\n        while(i < diffstr.length){\n            var line = diffstr[i]; // File header found, end parsing diff metadata\n            if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n                break;\n            } // Diff index\n            var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n            if (header) {\n                index.index = header[1];\n            }\n            i++;\n        } // Parse file headers if they are defined. Unified diff requires them, but\n        // there's no technical issues to have an isolated hunk without file header\n        parseFileHeader(index);\n        parseFileHeader(index); // Parse hunks\n        index.hunks = [];\n        while(i < diffstr.length){\n            var _line = diffstr[i];\n            if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) {\n                break;\n            } else if (/^@@/.test(_line)) {\n                index.hunks.push(parseHunk());\n            } else if (_line && options.strict) {\n                // Ignore unexpected content unless in strict mode\n                throw new Error(\"Unknown line \" + (i + 1) + \" \" + JSON.stringify(_line));\n            } else {\n                i++;\n            }\n        }\n    } // Parses the --- and +++ headers, if none are found, no lines\n    // are consumed.\n    function parseFileHeader(index) {\n        var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)$/.exec(diffstr[i]);\n        if (fileHeader) {\n            var keyPrefix = fileHeader[1] === \"---\" ? \"old\" : \"new\";\n            var data = fileHeader[2].split(\"\t\", 2);\n            var fileName = data[0].replace(/\\\\\\\\/g, \"\\\\\");\n            if (/^\".*\"$/.test(fileName)) {\n                fileName = fileName.substr(1, fileName.length - 2);\n            }\n            index[keyPrefix + \"FileName\"] = fileName;\n            index[keyPrefix + \"Header\"] = (data[1] || \"\").trim();\n            i++;\n        }\n    } // Parses a hunk\n    // This assumes that we are at the start of a hunk.\n    function parseHunk() {\n        var chunkHeaderIndex = i, chunkHeaderLine = diffstr[i++], chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n        var hunk = {\n            oldStart: +chunkHeader[1],\n            oldLines: typeof chunkHeader[2] === \"undefined\" ? 1 : +chunkHeader[2],\n            newStart: +chunkHeader[3],\n            newLines: typeof chunkHeader[4] === \"undefined\" ? 1 : +chunkHeader[4],\n            lines: [],\n            linedelimiters: []\n        }; // Unified Diff Format quirk: If the chunk size is 0,\n        // the first number is one lower than one would expect.\n        // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n        if (hunk.oldLines === 0) {\n            hunk.oldStart += 1;\n        }\n        if (hunk.newLines === 0) {\n            hunk.newStart += 1;\n        }\n        var addCount = 0, removeCount = 0;\n        for(; i < diffstr.length; i++){\n            // Lines starting with '---' could be mistaken for the \"remove line\" operation\n            // But they could be the header for the next file. Therefore prune such cases out.\n            if (diffstr[i].indexOf(\"--- \") === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf(\"+++ \") === 0 && diffstr[i + 2].indexOf(\"@@\") === 0) {\n                break;\n            }\n            var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? \" \" : diffstr[i][0];\n            if (operation === \"+\" || operation === \"-\" || operation === \" \" || operation === \"\\\\\") {\n                hunk.lines.push(diffstr[i]);\n                hunk.linedelimiters.push(delimiters[i] || \"\\n\");\n                if (operation === \"+\") {\n                    addCount++;\n                } else if (operation === \"-\") {\n                    removeCount++;\n                } else if (operation === \" \") {\n                    addCount++;\n                    removeCount++;\n                }\n            } else {\n                break;\n            }\n        } // Handle the empty block count case\n        if (!addCount && hunk.newLines === 1) {\n            hunk.newLines = 0;\n        }\n        if (!removeCount && hunk.oldLines === 1) {\n            hunk.oldLines = 0;\n        } // Perform optional sanity checking\n        if (options.strict) {\n            if (addCount !== hunk.newLines) {\n                throw new Error(\"Added line count did not match for hunk at line \" + (chunkHeaderIndex + 1));\n            }\n            if (removeCount !== hunk.oldLines) {\n                throw new Error(\"Removed line count did not match for hunk at line \" + (chunkHeaderIndex + 1));\n            }\n        }\n        return hunk;\n    }\n    while(i < diffstr.length){\n        parseIndex();\n    }\n    return list;\n}\n// Iterator that traverses in the range of [min, max], stepping\n// by distance from a given start position. I.e. for [0, 4], with\n// start of 2, this will iterate 2, 3, 1, 4, 0.\nfunction distanceIterator(start, minLine, maxLine) {\n    var wantForward = true, backwardExhausted = false, forwardExhausted = false, localOffset = 1;\n    return function iterator() {\n        if (wantForward && !forwardExhausted) {\n            if (backwardExhausted) {\n                localOffset++;\n            } else {\n                wantForward = false;\n            } // Check if trying to fit beyond text length, and if not, check it fits\n            // after offset location (or desired location on first iteration)\n            if (start + localOffset <= maxLine) {\n                return localOffset;\n            }\n            forwardExhausted = true;\n        }\n        if (!backwardExhausted) {\n            if (!forwardExhausted) {\n                wantForward = true;\n            } // Check if trying to fit before text beginning, and if not, check it fits\n            // before offset location\n            if (minLine <= start - localOffset) {\n                return -localOffset++;\n            }\n            backwardExhausted = true;\n            return iterator();\n        } // We tried to fit hunk before text beginning and beyond text length, then\n    // hunk can't fit on the text. Return undefined\n    };\n}\nfunction applyPatch(source, uniDiff) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (typeof uniDiff === \"string\") {\n        uniDiff = parsePatch(uniDiff);\n    }\n    if (Array.isArray(uniDiff)) {\n        if (uniDiff.length > 1) {\n            throw new Error(\"applyPatch only works with a single input.\");\n        }\n        uniDiff = uniDiff[0];\n    } // Apply the diff to the input\n    var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/), delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [], hunks = uniDiff.hunks, compareLine = options.compareLine || function(lineNumber, line, operation, patchContent) {\n        return line === patchContent;\n    }, errorCount = 0, fuzzFactor = options.fuzzFactor || 0, minLine = 0, offset = 0, removeEOFNL, addEOFNL;\n    /**\n   * Checks if the hunk exactly fits on the provided location\n   */ function hunkFits(hunk, toPos) {\n        for(var j = 0; j < hunk.lines.length; j++){\n            var line = hunk.lines[j], operation = line.length > 0 ? line[0] : \" \", content = line.length > 0 ? line.substr(1) : line;\n            if (operation === \" \" || operation === \"-\") {\n                // Context sanity check\n                if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n                    errorCount++;\n                    if (errorCount > fuzzFactor) {\n                        return false;\n                    }\n                }\n                toPos++;\n            }\n        }\n        return true;\n    } // Search best fit offsets for each hunk based on the previous ones\n    for(var i = 0; i < hunks.length; i++){\n        var hunk = hunks[i], maxLine = lines.length - hunk.oldLines, localOffset = 0, toPos = offset + hunk.oldStart - 1;\n        var iterator = distanceIterator(toPos, minLine, maxLine);\n        for(; localOffset !== undefined; localOffset = iterator()){\n            if (hunkFits(hunk, toPos + localOffset)) {\n                hunk.offset = offset += localOffset;\n                break;\n            }\n        }\n        if (localOffset === undefined) {\n            return false;\n        } // Set lower text limit to end of the current hunk, so next ones don't try\n        // to fit over already patched text\n        minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n    } // Apply patch hunks\n    var diffOffset = 0;\n    for(var _i = 0; _i < hunks.length; _i++){\n        var _hunk = hunks[_i], _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;\n        diffOffset += _hunk.newLines - _hunk.oldLines;\n        for(var j = 0; j < _hunk.lines.length; j++){\n            var line = _hunk.lines[j], operation = line.length > 0 ? line[0] : \" \", content = line.length > 0 ? line.substr(1) : line, delimiter = _hunk.linedelimiters && _hunk.linedelimiters[j] || \"\\n\";\n            if (operation === \" \") {\n                _toPos++;\n            } else if (operation === \"-\") {\n                lines.splice(_toPos, 1);\n                delimiters.splice(_toPos, 1);\n            /* istanbul ignore else */ } else if (operation === \"+\") {\n                lines.splice(_toPos, 0, content);\n                delimiters.splice(_toPos, 0, delimiter);\n                _toPos++;\n            } else if (operation === \"\\\\\") {\n                var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\n                if (previousOperation === \"+\") {\n                    removeEOFNL = true;\n                } else if (previousOperation === \"-\") {\n                    addEOFNL = true;\n                }\n            }\n        }\n    } // Handle EOFNL insertion/removal\n    if (removeEOFNL) {\n        while(!lines[lines.length - 1]){\n            lines.pop();\n            delimiters.pop();\n        }\n    } else if (addEOFNL) {\n        lines.push(\"\");\n        delimiters.push(\"\\n\");\n    }\n    for(var _k = 0; _k < lines.length - 1; _k++){\n        lines[_k] = lines[_k] + delimiters[_k];\n    }\n    return lines.join(\"\");\n} // Wrapper that supports multiple file patches via callbacks.\nfunction applyPatches(uniDiff, options) {\n    if (typeof uniDiff === \"string\") {\n        uniDiff = parsePatch(uniDiff);\n    }\n    var currentIndex = 0;\n    function processIndex() {\n        var index = uniDiff[currentIndex++];\n        if (!index) {\n            return options.complete();\n        }\n        options.loadFile(index, function(err, data) {\n            if (err) {\n                return options.complete(err);\n            }\n            var updatedContent = applyPatch(data, index, options);\n            options.patched(index, updatedContent, function(err) {\n                if (err) {\n                    return options.complete(err);\n                }\n                processIndex();\n            });\n        });\n    }\n    processIndex();\n}\nfunction structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n    if (!options) {\n        options = {};\n    }\n    if (typeof options.context === \"undefined\") {\n        options.context = 4;\n    }\n    var diff = diffLines(oldStr, newStr, options);\n    if (!diff) {\n        return;\n    }\n    diff.push({\n        value: \"\",\n        lines: []\n    }); // Append an empty value to make cleanup easier\n    function contextLines(lines) {\n        return lines.map(function(entry) {\n            return \" \" + entry;\n        });\n    }\n    var hunks = [];\n    var oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1;\n    var _loop = function _loop(i) {\n        var current = diff[i], lines = current.lines || current.value.replace(/\\n$/, \"\").split(\"\\n\");\n        current.lines = lines;\n        if (current.added || current.removed) {\n            var _curRange;\n            // If we have previous context, start with that\n            if (!oldRangeStart) {\n                var prev = diff[i - 1];\n                oldRangeStart = oldLine;\n                newRangeStart = newLine;\n                if (prev) {\n                    curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n                    oldRangeStart -= curRange.length;\n                    newRangeStart -= curRange.length;\n                }\n            } // Output our changes\n            (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function(entry) {\n                return (current.added ? \"+\" : \"-\") + entry;\n            }))); // Track the updated file position\n            if (current.added) {\n                newLine += lines.length;\n            } else {\n                oldLine += lines.length;\n            }\n        } else {\n            // Identical context lines. Track line changes\n            if (oldRangeStart) {\n                // Close out any changes that have been output (or join overlapping)\n                if (lines.length <= options.context * 2 && i < diff.length - 2) {\n                    var _curRange2;\n                    // Overlapping\n                    (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));\n                } else {\n                    var _curRange3;\n                    // end the range and output\n                    var contextSize = Math.min(lines.length, options.context);\n                    (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));\n                    var hunk = {\n                        oldStart: oldRangeStart,\n                        oldLines: oldLine - oldRangeStart + contextSize,\n                        newStart: newRangeStart,\n                        newLines: newLine - newRangeStart + contextSize,\n                        lines: curRange\n                    };\n                    if (i >= diff.length - 2 && lines.length <= options.context) {\n                        // EOF is inside this hunk\n                        var oldEOFNewline = /\\n$/.test(oldStr);\n                        var newEOFNewline = /\\n$/.test(newStr);\n                        var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;\n                        if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {\n                            // special case: old has no eol and no trailing context; no-nl can end up before adds\n                            // however, if the old file is empty, do not output the no-nl line\n                            curRange.splice(hunk.oldLines, 0, \"\\\\ No newline at end of file\");\n                        }\n                        if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {\n                            curRange.push(\"\\\\ No newline at end of file\");\n                        }\n                    }\n                    hunks.push(hunk);\n                    oldRangeStart = 0;\n                    newRangeStart = 0;\n                    curRange = [];\n                }\n            }\n            oldLine += lines.length;\n            newLine += lines.length;\n        }\n    };\n    for(var i = 0; i < diff.length; i++){\n        _loop(i);\n    }\n    return {\n        oldFileName: oldFileName,\n        newFileName: newFileName,\n        oldHeader: oldHeader,\n        newHeader: newHeader,\n        hunks: hunks\n    };\n}\nfunction formatPatch(diff) {\n    if (Array.isArray(diff)) {\n        return diff.map(formatPatch).join(\"\\n\");\n    }\n    var ret = [];\n    if (diff.oldFileName == diff.newFileName) {\n        ret.push(\"Index: \" + diff.oldFileName);\n    }\n    ret.push(\"===================================================================\");\n    ret.push(\"--- \" + diff.oldFileName + (typeof diff.oldHeader === \"undefined\" ? \"\" : \"\t\" + diff.oldHeader));\n    ret.push(\"+++ \" + diff.newFileName + (typeof diff.newHeader === \"undefined\" ? \"\" : \"\t\" + diff.newHeader));\n    for(var i = 0; i < diff.hunks.length; i++){\n        var hunk = diff.hunks[i]; // Unified Diff Format quirk: If the chunk size is 0,\n        // the first number is one lower than one would expect.\n        // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n        if (hunk.oldLines === 0) {\n            hunk.oldStart -= 1;\n        }\n        if (hunk.newLines === 0) {\n            hunk.newStart -= 1;\n        }\n        ret.push(\"@@ -\" + hunk.oldStart + \",\" + hunk.oldLines + \" +\" + hunk.newStart + \",\" + hunk.newLines + \" @@\");\n        ret.push.apply(ret, hunk.lines);\n    }\n    return ret.join(\"\\n\") + \"\\n\";\n}\nfunction createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n    return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));\n}\nfunction createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n    return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n}\nfunction arrayEqual(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    return arrayStartsWith(a, b);\n}\nfunction arrayStartsWith(array, start) {\n    if (start.length > array.length) {\n        return false;\n    }\n    for(var i = 0; i < start.length; i++){\n        if (start[i] !== array[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction calcLineCount(hunk) {\n    var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines), oldLines = _calcOldNewLineCount.oldLines, newLines = _calcOldNewLineCount.newLines;\n    if (oldLines !== undefined) {\n        hunk.oldLines = oldLines;\n    } else {\n        delete hunk.oldLines;\n    }\n    if (newLines !== undefined) {\n        hunk.newLines = newLines;\n    } else {\n        delete hunk.newLines;\n    }\n}\nfunction merge(mine, theirs, base) {\n    mine = loadPatch(mine, base);\n    theirs = loadPatch(theirs, base);\n    var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.\n    // Leaving sanity checks on this to the API consumer that may know more about the\n    // meaning in their own context.\n    if (mine.index || theirs.index) {\n        ret.index = mine.index || theirs.index;\n    }\n    if (mine.newFileName || theirs.newFileName) {\n        if (!fileNameChanged(mine)) {\n            // No header or no change in ours, use theirs (and ours if theirs does not exist)\n            ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n            ret.newFileName = theirs.newFileName || mine.newFileName;\n            ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n            ret.newHeader = theirs.newHeader || mine.newHeader;\n        } else if (!fileNameChanged(theirs)) {\n            // No header or no change in theirs, use ours\n            ret.oldFileName = mine.oldFileName;\n            ret.newFileName = mine.newFileName;\n            ret.oldHeader = mine.oldHeader;\n            ret.newHeader = mine.newHeader;\n        } else {\n            // Both changed... figure it out\n            ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n            ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n            ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n            ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n        }\n    }\n    ret.hunks = [];\n    var mineIndex = 0, theirsIndex = 0, mineOffset = 0, theirsOffset = 0;\n    while(mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length){\n        var mineCurrent = mine.hunks[mineIndex] || {\n            oldStart: Infinity\n        }, theirsCurrent = theirs.hunks[theirsIndex] || {\n            oldStart: Infinity\n        };\n        if (hunkBefore(mineCurrent, theirsCurrent)) {\n            // This patch does not overlap with any of the others, yay.\n            ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n            mineIndex++;\n            theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n        } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n            // This patch does not overlap with any of the others, yay.\n            ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n            theirsIndex++;\n            mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n        } else {\n            // Overlap, merge as best we can\n            var mergedHunk = {\n                oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n                oldLines: 0,\n                newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n                newLines: 0,\n                lines: []\n            };\n            mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n            theirsIndex++;\n            mineIndex++;\n            ret.hunks.push(mergedHunk);\n        }\n    }\n    return ret;\n}\nfunction loadPatch(param, base) {\n    if (typeof param === \"string\") {\n        if (/^@@/m.test(param) || /^Index:/m.test(param)) {\n            return parsePatch(param)[0];\n        }\n        if (!base) {\n            throw new Error(\"Must provide a base reference or pass in a patch\");\n        }\n        return structuredPatch(undefined, undefined, base, param);\n    }\n    return param;\n}\nfunction fileNameChanged(patch) {\n    return patch.newFileName && patch.newFileName !== patch.oldFileName;\n}\nfunction selectField(index, mine, theirs) {\n    if (mine === theirs) {\n        return mine;\n    } else {\n        index.conflict = true;\n        return {\n            mine: mine,\n            theirs: theirs\n        };\n    }\n}\nfunction hunkBefore(test, check) {\n    return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\n}\nfunction cloneHunk(hunk, offset) {\n    return {\n        oldStart: hunk.oldStart,\n        oldLines: hunk.oldLines,\n        newStart: hunk.newStart + offset,\n        newLines: hunk.newLines,\n        lines: hunk.lines\n    };\n}\nfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n    // This will generally result in a conflicted hunk, but there are cases where the context\n    // is the only overlap where we can successfully merge the content here.\n    var mine = {\n        offset: mineOffset,\n        lines: mineLines,\n        index: 0\n    }, their = {\n        offset: theirOffset,\n        lines: theirLines,\n        index: 0\n    }; // Handle any leading content\n    insertLeading(hunk, mine, their);\n    insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.\n    while(mine.index < mine.lines.length && their.index < their.lines.length){\n        var mineCurrent = mine.lines[mine.index], theirCurrent = their.lines[their.index];\n        if ((mineCurrent[0] === \"-\" || mineCurrent[0] === \"+\") && (theirCurrent[0] === \"-\" || theirCurrent[0] === \"+\")) {\n            // Both modified ...\n            mutualChange(hunk, mine, their);\n        } else if (mineCurrent[0] === \"+\" && theirCurrent[0] === \" \") {\n            var _hunk$lines;\n            // Mine inserted\n            (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));\n        } else if (theirCurrent[0] === \"+\" && mineCurrent[0] === \" \") {\n            var _hunk$lines2;\n            // Theirs inserted\n            (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));\n        } else if (mineCurrent[0] === \"-\" && theirCurrent[0] === \" \") {\n            // Mine removed or edited\n            removal(hunk, mine, their);\n        } else if (theirCurrent[0] === \"-\" && mineCurrent[0] === \" \") {\n            // Their removed or edited\n            removal(hunk, their, mine, true);\n        } else if (mineCurrent === theirCurrent) {\n            // Context identity\n            hunk.lines.push(mineCurrent);\n            mine.index++;\n            their.index++;\n        } else {\n            // Context mismatch\n            conflict(hunk, collectChange(mine), collectChange(their));\n        }\n    } // Now push anything that may be remaining\n    insertTrailing(hunk, mine);\n    insertTrailing(hunk, their);\n    calcLineCount(hunk);\n}\nfunction mutualChange(hunk, mine, their) {\n    var myChanges = collectChange(mine), theirChanges = collectChange(their);\n    if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n        // Special case for remove changes that are supersets of one another\n        if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n            var _hunk$lines3;\n            (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));\n            return;\n        } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n            var _hunk$lines4;\n            (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));\n            return;\n        }\n    } else if (arrayEqual(myChanges, theirChanges)) {\n        var _hunk$lines5;\n        (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));\n        return;\n    }\n    conflict(hunk, myChanges, theirChanges);\n}\nfunction removal(hunk, mine, their, swap) {\n    var myChanges = collectChange(mine), theirChanges = collectContext(their, myChanges);\n    if (theirChanges.merged) {\n        var _hunk$lines6;\n        (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));\n    } else {\n        conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n    }\n}\nfunction conflict(hunk, mine, their) {\n    hunk.conflict = true;\n    hunk.lines.push({\n        conflict: true,\n        mine: mine,\n        theirs: their\n    });\n}\nfunction insertLeading(hunk, insert, their) {\n    while(insert.offset < their.offset && insert.index < insert.lines.length){\n        var line = insert.lines[insert.index++];\n        hunk.lines.push(line);\n        insert.offset++;\n    }\n}\nfunction insertTrailing(hunk, insert) {\n    while(insert.index < insert.lines.length){\n        var line = insert.lines[insert.index++];\n        hunk.lines.push(line);\n    }\n}\nfunction collectChange(state) {\n    var ret = [], operation = state.lines[state.index][0];\n    while(state.index < state.lines.length){\n        var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n        if (operation === \"-\" && line[0] === \"+\") {\n            operation = \"+\";\n        }\n        if (operation === line[0]) {\n            ret.push(line);\n            state.index++;\n        } else {\n            break;\n        }\n    }\n    return ret;\n}\nfunction collectContext(state, matchChanges) {\n    var changes = [], merged = [], matchIndex = 0, contextChanges = false, conflicted = false;\n    while(matchIndex < matchChanges.length && state.index < state.lines.length){\n        var change = state.lines[state.index], match = matchChanges[matchIndex]; // Once we've hit our add, then we are done\n        if (match[0] === \"+\") {\n            break;\n        }\n        contextChanges = contextChanges || change[0] !== \" \";\n        merged.push(match);\n        matchIndex++; // Consume any additions in the other block as a conflict to attempt\n        // to pull in the remaining context after this\n        if (change[0] === \"+\") {\n            conflicted = true;\n            while(change[0] === \"+\"){\n                changes.push(change);\n                change = state.lines[++state.index];\n            }\n        }\n        if (match.substr(1) === change.substr(1)) {\n            changes.push(change);\n            state.index++;\n        } else {\n            conflicted = true;\n        }\n    }\n    if ((matchChanges[matchIndex] || \"\")[0] === \"+\" && contextChanges) {\n        conflicted = true;\n    }\n    if (conflicted) {\n        return changes;\n    }\n    while(matchIndex < matchChanges.length){\n        merged.push(matchChanges[matchIndex++]);\n    }\n    return {\n        merged: merged,\n        changes: changes\n    };\n}\nfunction allRemoves(changes) {\n    return changes.reduce(function(prev, change) {\n        return prev && change[0] === \"-\";\n    }, true);\n}\nfunction skipRemoveSuperset(state, removeChanges, delta) {\n    for(var i = 0; i < delta; i++){\n        var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n        if (state.lines[state.index + i] !== \" \" + changeContent) {\n            return false;\n        }\n    }\n    state.index += delta;\n    return true;\n}\nfunction calcOldNewLineCount(lines) {\n    var oldLines = 0;\n    var newLines = 0;\n    lines.forEach(function(line) {\n        if (typeof line !== \"string\") {\n            var myCount = calcOldNewLineCount(line.mine);\n            var theirCount = calcOldNewLineCount(line.theirs);\n            if (oldLines !== undefined) {\n                if (myCount.oldLines === theirCount.oldLines) {\n                    oldLines += myCount.oldLines;\n                } else {\n                    oldLines = undefined;\n                }\n            }\n            if (newLines !== undefined) {\n                if (myCount.newLines === theirCount.newLines) {\n                    newLines += myCount.newLines;\n                } else {\n                    newLines = undefined;\n                }\n            }\n        } else {\n            if (newLines !== undefined && (line[0] === \"+\" || line[0] === \" \")) {\n                newLines++;\n            }\n            if (oldLines !== undefined && (line[0] === \"-\" || line[0] === \" \")) {\n                oldLines++;\n            }\n        }\n    });\n    return {\n        oldLines: oldLines,\n        newLines: newLines\n    };\n}\nfunction reversePatch(structuredPatch) {\n    if (Array.isArray(structuredPatch)) {\n        return structuredPatch.map(reversePatch).reverse();\n    }\n    return _objectSpread2(_objectSpread2({}, structuredPatch), {}, {\n        oldFileName: structuredPatch.newFileName,\n        oldHeader: structuredPatch.newHeader,\n        newFileName: structuredPatch.oldFileName,\n        newHeader: structuredPatch.oldHeader,\n        hunks: structuredPatch.hunks.map(function(hunk) {\n            return {\n                oldLines: hunk.newLines,\n                oldStart: hunk.newStart,\n                newLines: hunk.oldLines,\n                newStart: hunk.oldStart,\n                linedelimiters: hunk.linedelimiters,\n                lines: hunk.lines.map(function(l) {\n                    if (l.startsWith(\"-\")) {\n                        return \"+\".concat(l.slice(1));\n                    }\n                    if (l.startsWith(\"+\")) {\n                        return \"-\".concat(l.slice(1));\n                    }\n                    return l;\n                })\n            };\n        })\n    });\n}\n// See: http://code.google.com/p/google-diff-match-patch/wiki/API\nfunction convertChangesToDMP(changes) {\n    var ret = [], change, operation;\n    for(var i = 0; i < changes.length; i++){\n        change = changes[i];\n        if (change.added) {\n            operation = 1;\n        } else if (change.removed) {\n            operation = -1;\n        } else {\n            operation = 0;\n        }\n        ret.push([\n            operation,\n            change.value\n        ]);\n    }\n    return ret;\n}\nfunction convertChangesToXML(changes) {\n    var ret = [];\n    for(var i = 0; i < changes.length; i++){\n        var change = changes[i];\n        if (change.added) {\n            ret.push(\"<ins>\");\n        } else if (change.removed) {\n            ret.push(\"<del>\");\n        }\n        ret.push(escapeHTML(change.value));\n        if (change.added) {\n            ret.push(\"</ins>\");\n        } else if (change.removed) {\n            ret.push(\"</del>\");\n        }\n    }\n    return ret.join(\"\");\n}\nfunction escapeHTML(s) {\n    var n = s;\n    n = n.replace(/&/g, \"&amp;\");\n    n = n.replace(/</g, \"&lt;\");\n    n = n.replace(/>/g, \"&gt;\");\n    n = n.replace(/\"/g, \"&quot;\");\n    return n;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdXZ1L25vZGVfbW9kdWxlcy9kaWZmL2xpYi9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLFNBQVNBLFFBQVE7QUFDakJBLEtBQUtDLFNBQVMsR0FBRztJQUNmQyxNQUFNLFNBQVNBLEtBQUtDLFNBQVMsRUFBRUMsU0FBUztRQUN0QyxJQUFJQztRQUVKLElBQUlDLFVBQVVDLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDbkYsSUFBSUcsV0FBV0osUUFBUUksUUFBUTtRQUUvQixJQUFJLE9BQU9KLFlBQVksWUFBWTtZQUNqQ0ksV0FBV0o7WUFDWEEsVUFBVSxDQUFDO1FBQ2I7UUFFQSxJQUFJLENBQUNBLE9BQU8sR0FBR0E7UUFDZixJQUFJSyxPQUFPLElBQUk7UUFFZixTQUFTQyxLQUFLQyxLQUFLO1lBQ2pCLElBQUlILFVBQVU7Z0JBQ1pJLFdBQVc7b0JBQ1RKLFNBQVNELFdBQVdJO2dCQUN0QixHQUFHO2dCQUNILE9BQU87WUFDVCxPQUFPO2dCQUNMLE9BQU9BO1lBQ1Q7UUFDRixFQUFFLHlEQUF5RDtRQUczRFYsWUFBWSxJQUFJLENBQUNZLFNBQVMsQ0FBQ1o7UUFDM0JDLFlBQVksSUFBSSxDQUFDVyxTQUFTLENBQUNYO1FBQzNCRCxZQUFZLElBQUksQ0FBQ2EsV0FBVyxDQUFDLElBQUksQ0FBQ0MsUUFBUSxDQUFDZDtRQUMzQ0MsWUFBWSxJQUFJLENBQUNZLFdBQVcsQ0FBQyxJQUFJLENBQUNDLFFBQVEsQ0FBQ2I7UUFDM0MsSUFBSWMsU0FBU2QsVUFBVUksTUFBTSxFQUN6QlcsU0FBU2hCLFVBQVVLLE1BQU07UUFDN0IsSUFBSVksYUFBYTtRQUNqQixJQUFJQyxnQkFBZ0JILFNBQVNDO1FBRTdCLElBQUliLFFBQVFlLGFBQWEsRUFBRTtZQUN6QkEsZ0JBQWdCQyxLQUFLQyxHQUFH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QUNoQkYsSUFBSWdCLElBQUksQ0FBQztRQUNYLE9BQU8sSUFBSWlSLE9BQU85UixPQUFPLEVBQUU7WUFDekJILElBQUlnQixJQUFJLENBQUM7UUFDWDtRQUVBaEIsSUFBSWdCLElBQUksQ0FBQzhSLFdBQVdiLE9BQU94VSxLQUFLO1FBRWhDLElBQUl3VSxPQUFPL1IsS0FBSyxFQUFFO1lBQ2hCRixJQUFJZ0IsSUFBSSxDQUFDO1FBQ1gsT0FBTyxJQUFJaVIsT0FBTzlSLE9BQU8sRUFBRTtZQUN6QkgsSUFBSWdCLElBQUksQ0FBQztRQUNYO0lBQ0Y7SUFFQSxPQUFPaEIsSUFBSWpCLElBQUksQ0FBQztBQUNsQjtBQUVBLFNBQVMrVCxXQUFXQyxDQUFDO0lBQ25CLElBQUl4TSxJQUFJd007SUFDUnhNLElBQUlBLEVBQUVyRCxPQUFPLENBQUMsTUFBTTtJQUNwQnFELElBQUlBLEVBQUVyRCxPQUFPLENBQUMsTUFBTTtJQUNwQnFELElBQUlBLEVBQUVyRCxPQUFPLENBQUMsTUFBTTtJQUNwQnFELElBQUlBLEVBQUVyRCxPQUFPLENBQUMsTUFBTTtJQUNwQixPQUFPcUQ7QUFDVDtBQUV3VCIsInNvdXJjZXMiOlsid2VicGFjazovL3RheG9ub215Ly4vbm9kZV9tb2R1bGVzL3V2dS9ub2RlX21vZHVsZXMvZGlmZi9saWIvaW5kZXgubWpzPzgxMWMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gRGlmZigpIHt9XG5EaWZmLnByb3RvdHlwZSA9IHtcbiAgZGlmZjogZnVuY3Rpb24gZGlmZihvbGRTdHJpbmcsIG5ld1N0cmluZykge1xuICAgIHZhciBfb3B0aW9ucyR0aW1lb3V0O1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIGRvbmUodmFsdWUpIHtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYWxsYmFjayh1bmRlZmluZWQsIHZhbHVlKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH0gLy8gQWxsb3cgc3ViY2xhc3NlcyB0byBtYXNzYWdlIHRoZSBpbnB1dCBwcmlvciB0byBydW5uaW5nXG5cblxuICAgIG9sZFN0cmluZyA9IHRoaXMuY2FzdElucHV0KG9sZFN0cmluZyk7XG4gICAgbmV3U3RyaW5nID0gdGhpcy5jYXN0SW5wdXQobmV3U3RyaW5nKTtcbiAgICBvbGRTdHJpbmcgPSB0aGlzLnJlbW92ZUVtcHR5KHRoaXMudG9rZW5pemUob2xkU3RyaW5nKSk7XG4gICAgbmV3U3RyaW5nID0gdGhpcy5yZW1vdmVFbXB0eSh0aGlzLnRva2VuaXplKG5ld1N0cmluZykpO1xuICAgIHZhciBuZXdMZW4gPSBuZXdTdHJpbmcubGVuZ3RoLFxuICAgICAgICBvbGRMZW4gPSBvbGRTdHJpbmcubGVuZ3RoO1xuICAgIHZhciBlZGl0TGVuZ3RoID0gMTtcbiAgICB2YXIgbWF4RWRpdExlbmd0aCA9IG5ld0xlbiArIG9sZExlbjtcblxuICAgIGlmIChvcHRpb25zLm1heEVkaXRMZW5ndGgpIHtcbiAgICAgIG1heEVkaXRMZW5ndGggPSBNYXRoLm1pbihtYXhFZGl0TGVuZ3RoLCBvcHRpb25zLm1heEVkaXRMZW5ndGgpO1xuICAgIH1cblxuICAgIHZhciBtYXhFeGVjdXRpb25UaW1lID0gKF9vcHRpb25zJHRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQpICE9PSBudWxsICYmIF9vcHRpb25zJHRpbWVvdXQgIT09IHZvaWQgMCA/IF9vcHRpb25zJHRpbWVvdXQgOiBJbmZpbml0eTtcbiAgICB2YXIgYWJvcnRBZnRlclRpbWVzdGFtcCA9IERhdGUubm93KCkgKyBtYXhFeGVjdXRpb25UaW1lO1xuICAgIHZhciBiZXN0UGF0aCA9IFt7XG4gICAgICBvbGRQb3M6IC0xLFxuICAgICAgbGFzdENvbXBvbmVudDogdW5kZWZpbmVkXG4gICAgfV07IC8vIFNlZWQgZWRpdExlbmd0aCA9IDAsIGkuZS4gdGhlIGNvbnRlbnQgc3RhcnRzIHdpdGggdGhlIHNhbWUgdmFsdWVzXG5cbiAgICB2YXIgbmV3UG9zID0gdGhpcy5leHRyYWN0Q29tbW9uKGJlc3RQYXRoWzBdLCBuZXdTdHJpbmcsIG9sZFN0cmluZywgMCk7XG5cbiAgICBpZiAoYmVzdFBhdGhbMF0ub2xkUG9zICsgMSA+PSBvbGRMZW4gJiYgbmV3UG9zICsgMSA+PSBuZXdMZW4pIHtcbiAgICAgIC8vIElkZW50aXR5IHBlciB0aGUgZXF1YWxpdHkgYW5kIHRva2VuaXplclxuICAgICAgcmV0dXJuIGRvbmUoW3tcbiAgICAgICAgdmFsdWU6IHRoaXMuam9pbihuZXdTdHJpbmcpLFxuICAgICAgICBjb3VudDogbmV3U3RyaW5nLmxlbmd0aFxuICAgICAgfV0pO1xuICAgIH0gLy8gT25jZSB3ZSBoaXQgdGhlIHJpZ2h0IGVkZ2Ugb2YgdGhlIGVkaXQgZ3JhcGggb24gc29tZSBkaWFnb25hbCBrLCB3ZSBjYW5cbiAgICAvLyBkZWZpbml0ZWx5IHJlYWNoIHRoZSBlbmQgb2YgdGhlIGVkaXQgZ3JhcGggaW4gbm8gbW9yZSB0aGFuIGsgZWRpdHMsIHNvXG4gICAgLy8gdGhlcmUncyBubyBwb2ludCBpbiBjb25zaWRlcmluZyBhbnkgbW92ZXMgdG8gZGlhZ29uYWwgaysxIGFueSBtb3JlIChmcm9tXG4gICAgLy8gd2hpY2ggd2UncmUgZ3VhcmFudGVlZCB0byBuZWVkIGF0IGxlYXN0IGsrMSBtb3JlIGVkaXRzKS5cbiAgICAvLyBTaW1pbGFybHksIG9uY2Ugd2UndmUgcmVhY2hlZCB0aGUgYm90dG9tIG9mIHRoZSBlZGl0IGdyYXBoLCB0aGVyZSdzIG5vXG4gICAgLy8gcG9pbnQgY29uc2lkZXJpbmcgbW92ZXMgdG8gbG93ZXIgZGlhZ29uYWxzLlxuICAgIC8vIFdlIHJlY29yZCB0aGlzIGZhY3QgYnkgc2V0dGluZyBtaW5EaWFnb25hbFRvQ29uc2lkZXIgYW5kXG4gICAgLy8gbWF4RGlhZ29uYWxUb0NvbnNpZGVyIHRvIHNvbWUgZmluaXRlIHZhbHVlIG9uY2Ugd2UndmUgaGl0IHRoZSBlZGdlIG9mXG4gICAgLy8gdGhlIGVkaXQgZ3JhcGguXG4gICAgLy8gVGhpcyBvcHRpbWl6YXRpb24gaXMgbm90IGZhaXRoZnVsIHRvIHRoZSBvcmlnaW5hbCBhbGdvcml0aG0gcHJlc2VudGVkIGluXG4gICAgLy8gTXllcnMncyBwYXBlciwgd2hpY2ggaW5zdGVhZCBwb2ludGxlc3NseSBleHRlbmRzIEQtcGF0aHMgb2ZmIHRoZSBlbmQgb2ZcbiAgICAvLyB0aGUgZWRpdCBncmFwaCAtIHNlZSBwYWdlIDcgb2YgTXllcnMncyBwYXBlciB3aGljaCBub3RlcyB0aGlzIHBvaW50XG4gICAgLy8gZXhwbGljaXRseSBhbmQgaWxsdXN0cmF0ZXMgaXQgd2l0aCBhIGRpYWdyYW0uIFRoaXMgaGFzIG1ham9yIHBlcmZvcm1hbmNlXG4gICAgLy8gaW1wbGljYXRpb25zIGZvciBzb21lIGNvbW1vbiBzY2VuYXJpb3MuIEZvciBpbnN0YW5jZSwgdG8gY29tcHV0ZSBhIGRpZmZcbiAgICAvLyB3aGVyZSB0aGUgbmV3IHRleHQgc2ltcGx5IGFwcGVuZHMgZCBjaGFyYWN0ZXJzIG9uIHRoZSBlbmQgb2YgdGhlXG4gICAgLy8gb3JpZ2luYWwgdGV4dCBvZiBsZW5ndGggbiwgdGhlIHRydWUgTXllcnMgYWxnb3JpdGhtIHdpbGwgdGFrZSBPKG4rZF4yKVxuICAgIC8vIHRpbWUgd2hpbGUgdGhpcyBvcHRpbWl6YXRpb24gbmVlZHMgb25seSBPKG4rZCkgdGltZS5cblxuXG4gICAgdmFyIG1pbkRpYWdvbmFsVG9Db25zaWRlciA9IC1JbmZpbml0eSxcbiAgICAgICAgbWF4RGlhZ29uYWxUb0NvbnNpZGVyID0gSW5maW5pdHk7IC8vIE1haW4gd29ya2VyIG1ldGhvZC4gY2hlY2tzIGFsbCBwZXJtdXRhdGlvbnMgb2YgYSBnaXZlbiBlZGl0IGxlbmd0aCBmb3IgYWNjZXB0YW5jZS5cblxuICAgIGZ1bmN0aW9uIGV4ZWNFZGl0TGVuZ3RoKCkge1xuICAgICAgZm9yICh2YXIgZGlhZ29uYWxQYXRoID0gTWF0aC5tYXgobWluRGlhZ29uYWxUb0NvbnNpZGVyLCAtZWRpdExlbmd0aCk7IGRpYWdvbmFsUGF0aCA8PSBNYXRoLm1pbihtYXhEaWFnb25hbFRvQ29uc2lkZXIsIGVkaXRMZW5ndGgpOyBkaWFnb25hbFBhdGggKz0gMikge1xuICAgICAgICB2YXIgYmFzZVBhdGggPSB2b2lkIDA7XG4gICAgICAgIHZhciByZW1vdmVQYXRoID0gYmVzdFBhdGhbZGlhZ29uYWxQYXRoIC0gMV0sXG4gICAgICAgICAgICBhZGRQYXRoID0gYmVzdFBhdGhbZGlhZ29uYWxQYXRoICsgMV07XG5cbiAgICAgICAgaWYgKHJlbW92ZVBhdGgpIHtcbiAgICAgICAgICAvLyBObyBvbmUgZWxzZSBpcyBnb2luZyB0byBhdHRlbXB0IHRvIHVzZSB0aGlzIHZhbHVlLCBjbGVhciBpdFxuICAgICAgICAgIGJlc3RQYXRoW2RpYWdvbmFsUGF0aCAtIDFdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNhbkFkZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChhZGRQYXRoKSB7XG4gICAgICAgICAgLy8gd2hhdCBuZXdQb3Mgd2lsbCBiZSBhZnRlciB3ZSBkbyBhbiBpbnNlcnRpb246XG4gICAgICAgICAgdmFyIGFkZFBhdGhOZXdQb3MgPSBhZGRQYXRoLm9sZFBvcyAtIGRpYWdvbmFsUGF0aDtcbiAgICAgICAgICBjYW5BZGQgPSBhZGRQYXRoICYmIDAgPD0gYWRkUGF0aE5ld1BvcyAmJiBhZGRQYXRoTmV3UG9zIDwgbmV3TGVuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNhblJlbW92ZSA9IHJlbW92ZVBhdGggJiYgcmVtb3ZlUGF0aC5vbGRQb3MgKyAxIDwgb2xkTGVuO1xuXG4gICAgICAgIGlmICghY2FuQWRkICYmICFjYW5SZW1vdmUpIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIHBhdGggaXMgYSB0ZXJtaW5hbCB0aGVuIHBydW5lXG4gICAgICAgICAgYmVzdFBhdGhbZGlhZ29uYWxQYXRoXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBTZWxlY3QgdGhlIGRpYWdvbmFsIHRoYXQgd2Ugd2FudCB0byBicmFuY2ggZnJvbS4gV2Ugc2VsZWN0IHRoZSBwcmlvclxuICAgICAgICAvLyBwYXRoIHdob3NlIHBvc2l0aW9uIGluIHRoZSBvbGQgc3RyaW5nIGlzIHRoZSBmYXJ0aGVzdCBmcm9tIHRoZSBvcmlnaW5cbiAgICAgICAgLy8gYW5kIGRvZXMgbm90IHBhc3MgdGhlIGJvdW5kcyBvZiB0aGUgZGlmZiBncmFwaFxuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgdGhlIGArIDFgIGhlcmUgdG8gbWFrZSBiZWhhdmlvciBtYXRjaCBNeWVycyBhbGdvcml0aG1cbiAgICAgICAgLy8gICAgICAgYW5kIHByZWZlciB0byBvcmRlciByZW1vdmFscyBiZWZvcmUgaW5zZXJ0aW9ucy5cblxuXG4gICAgICAgIGlmICghY2FuUmVtb3ZlIHx8IGNhbkFkZCAmJiByZW1vdmVQYXRoLm9sZFBvcyArIDEgPCBhZGRQYXRoLm9sZFBvcykge1xuICAgICAgICAgIGJhc2VQYXRoID0gc2VsZi5hZGRUb1BhdGgoYWRkUGF0aCwgdHJ1ZSwgdW5kZWZpbmVkLCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiYXNlUGF0aCA9IHNlbGYuYWRkVG9QYXRoKHJlbW92ZVBhdGgsIHVuZGVmaW5lZCwgdHJ1ZSwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdQb3MgPSBzZWxmLmV4dHJhY3RDb21tb24oYmFzZVBhdGgsIG5ld1N0cmluZywgb2xkU3RyaW5nLCBkaWFnb25hbFBhdGgpO1xuXG4gICAgICAgIGlmIChiYXNlUGF0aC5vbGRQb3MgKyAxID49IG9sZExlbiAmJiBuZXdQb3MgKyAxID49IG5ld0xlbikge1xuICAgICAgICAgIC8vIElmIHdlIGhhdmUgaGl0IHRoZSBlbmQgb2YgYm90aCBzdHJpbmdzLCB0aGVuIHdlIGFyZSBkb25lXG4gICAgICAgICAgcmV0dXJuIGRvbmUoYnVpbGRWYWx1ZXMoc2VsZiwgYmFzZVBhdGgubGFzdENvbXBvbmVudCwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIHNlbGYudXNlTG9uZ2VzdFRva2VuKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmVzdFBhdGhbZGlhZ29uYWxQYXRoXSA9IGJhc2VQYXRoO1xuXG4gICAgICAgICAgaWYgKGJhc2VQYXRoLm9sZFBvcyArIDEgPj0gb2xkTGVuKSB7XG4gICAgICAgICAgICBtYXhEaWFnb25hbFRvQ29uc2lkZXIgPSBNYXRoLm1pbihtYXhEaWFnb25hbFRvQ29uc2lkZXIsIGRpYWdvbmFsUGF0aCAtIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuZXdQb3MgKyAxID49IG5ld0xlbikge1xuICAgICAgICAgICAgbWluRGlhZ29uYWxUb0NvbnNpZGVyID0gTWF0aC5tYXgobWluRGlhZ29uYWxUb0NvbnNpZGVyLCBkaWFnb25hbFBhdGggKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWRpdExlbmd0aCsrO1xuICAgIH0gLy8gUGVyZm9ybXMgdGhlIGxlbmd0aCBvZiBlZGl0IGl0ZXJhdGlvbi4gSXMgYSBiaXQgZnVnbHkgYXMgdGhpcyBoYXMgdG8gc3VwcG9ydCB0aGVcbiAgICAvLyBzeW5jIGFuZCBhc3luYyBtb2RlIHdoaWNoIGlzIG5ldmVyIGZ1bi4gTG9vcHMgb3ZlciBleGVjRWRpdExlbmd0aCB1bnRpbCBhIHZhbHVlXG4gICAgLy8gaXMgcHJvZHVjZWQsIG9yIHVudGlsIHRoZSBlZGl0IGxlbmd0aCBleGNlZWRzIG9wdGlvbnMubWF4RWRpdExlbmd0aCAoaWYgZ2l2ZW4pLFxuICAgIC8vIGluIHdoaWNoIGNhc2UgaXQgd2lsbCByZXR1cm4gdW5kZWZpbmVkLlxuXG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIChmdW5jdGlvbiBleGVjKCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZWRpdExlbmd0aCA+IG1heEVkaXRMZW5ndGggfHwgRGF0ZS5ub3coKSA+IGFib3J0QWZ0ZXJUaW1lc3RhbXApIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghZXhlY0VkaXRMZW5ndGgoKSkge1xuICAgICAgICAgICAgZXhlYygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgICB9KSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoZWRpdExlbmd0aCA8PSBtYXhFZGl0TGVuZ3RoICYmIERhdGUubm93KCkgPD0gYWJvcnRBZnRlclRpbWVzdGFtcCkge1xuICAgICAgICB2YXIgcmV0ID0gZXhlY0VkaXRMZW5ndGgoKTtcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYWRkVG9QYXRoOiBmdW5jdGlvbiBhZGRUb1BhdGgocGF0aCwgYWRkZWQsIHJlbW92ZWQsIG9sZFBvc0luYykge1xuICAgIHZhciBsYXN0ID0gcGF0aC5sYXN0Q29tcG9uZW50O1xuXG4gICAgaWYgKGxhc3QgJiYgbGFzdC5hZGRlZCA9PT0gYWRkZWQgJiYgbGFzdC5yZW1vdmVkID09PSByZW1vdmVkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvbGRQb3M6IHBhdGgub2xkUG9zICsgb2xkUG9zSW5jLFxuICAgICAgICBsYXN0Q29tcG9uZW50OiB7XG4gICAgICAgICAgY291bnQ6IGxhc3QuY291bnQgKyAxLFxuICAgICAgICAgIGFkZGVkOiBhZGRlZCxcbiAgICAgICAgICByZW1vdmVkOiByZW1vdmVkLFxuICAgICAgICAgIHByZXZpb3VzQ29tcG9uZW50OiBsYXN0LnByZXZpb3VzQ29tcG9uZW50XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9sZFBvczogcGF0aC5vbGRQb3MgKyBvbGRQb3NJbmMsXG4gICAgICAgIGxhc3RDb21wb25lbnQ6IHtcbiAgICAgICAgICBjb3VudDogMSxcbiAgICAgICAgICBhZGRlZDogYWRkZWQsXG4gICAgICAgICAgcmVtb3ZlZDogcmVtb3ZlZCxcbiAgICAgICAgICBwcmV2aW91c0NvbXBvbmVudDogbGFzdFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgZXh0cmFjdENvbW1vbjogZnVuY3Rpb24gZXh0cmFjdENvbW1vbihiYXNlUGF0aCwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIGRpYWdvbmFsUGF0aCkge1xuICAgIHZhciBuZXdMZW4gPSBuZXdTdHJpbmcubGVuZ3RoLFxuICAgICAgICBvbGRMZW4gPSBvbGRTdHJpbmcubGVuZ3RoLFxuICAgICAgICBvbGRQb3MgPSBiYXNlUGF0aC5vbGRQb3MsXG4gICAgICAgIG5ld1BvcyA9IG9sZFBvcyAtIGRpYWdvbmFsUGF0aCxcbiAgICAgICAgY29tbW9uQ291bnQgPSAwO1xuXG4gICAgd2hpbGUgKG5ld1BvcyArIDEgPCBuZXdMZW4gJiYgb2xkUG9zICsgMSA8IG9sZExlbiAmJiB0aGlzLmVxdWFscyhuZXdTdHJpbmdbbmV3UG9zICsgMV0sIG9sZFN0cmluZ1tvbGRQb3MgKyAxXSkpIHtcbiAgICAgIG5ld1BvcysrO1xuICAgICAgb2xkUG9zKys7XG4gICAgICBjb21tb25Db3VudCsrO1xuICAgIH1cblxuICAgIGlmIChjb21tb25Db3VudCkge1xuICAgICAgYmFzZVBhdGgubGFzdENvbXBvbmVudCA9IHtcbiAgICAgICAgY291bnQ6IGNvbW1vbkNvdW50LFxuICAgICAgICBwcmV2aW91c0NvbXBvbmVudDogYmFzZVBhdGgubGFzdENvbXBvbmVudFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBiYXNlUGF0aC5vbGRQb3MgPSBvbGRQb3M7XG4gICAgcmV0dXJuIG5ld1BvcztcbiAgfSxcbiAgZXF1YWxzOiBmdW5jdGlvbiBlcXVhbHMobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmNvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuY29tcGFyYXRvcihsZWZ0LCByaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBsZWZ0ID09PSByaWdodCB8fCB0aGlzLm9wdGlvbnMuaWdub3JlQ2FzZSAmJiBsZWZ0LnRvTG93ZXJDYXNlKCkgPT09IHJpZ2h0LnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICB9LFxuICByZW1vdmVFbXB0eTogZnVuY3Rpb24gcmVtb3ZlRW1wdHkoYXJyYXkpIHtcbiAgICB2YXIgcmV0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJyYXlbaV0pIHtcbiAgICAgICAgcmV0LnB1c2goYXJyYXlbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH0sXG4gIGNhc3RJbnB1dDogZnVuY3Rpb24gY2FzdElucHV0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICB0b2tlbml6ZTogZnVuY3Rpb24gdG9rZW5pemUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuc3BsaXQoJycpO1xuICB9LFxuICBqb2luOiBmdW5jdGlvbiBqb2luKGNoYXJzKSB7XG4gICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBidWlsZFZhbHVlcyhkaWZmLCBsYXN0Q29tcG9uZW50LCBuZXdTdHJpbmcsIG9sZFN0cmluZywgdXNlTG9uZ2VzdFRva2VuKSB7XG4gIC8vIEZpcnN0IHdlIGNvbnZlcnQgb3VyIGxpbmtlZCBsaXN0IG9mIGNvbXBvbmVudHMgaW4gcmV2ZXJzZSBvcmRlciB0byBhblxuICAvLyBhcnJheSBpbiB0aGUgcmlnaHQgb3JkZXI6XG4gIHZhciBjb21wb25lbnRzID0gW107XG4gIHZhciBuZXh0Q29tcG9uZW50O1xuXG4gIHdoaWxlIChsYXN0Q29tcG9uZW50KSB7XG4gICAgY29tcG9uZW50cy5wdXNoKGxhc3RDb21wb25lbnQpO1xuICAgIG5leHRDb21wb25lbnQgPSBsYXN0Q29tcG9uZW50LnByZXZpb3VzQ29tcG9uZW50O1xuICAgIGRlbGV0ZSBsYXN0Q29tcG9uZW50LnByZXZpb3VzQ29tcG9uZW50O1xuICAgIGxhc3RDb21wb25lbnQgPSBuZXh0Q29tcG9uZW50O1xuICB9XG5cbiAgY29tcG9uZW50cy5yZXZlcnNlKCk7XG4gIHZhciBjb21wb25lbnRQb3MgPSAwLFxuICAgICAgY29tcG9uZW50TGVuID0gY29tcG9uZW50cy5sZW5ndGgsXG4gICAgICBuZXdQb3MgPSAwLFxuICAgICAgb2xkUG9zID0gMDtcblxuICBmb3IgKDsgY29tcG9uZW50UG9zIDwgY29tcG9uZW50TGVuOyBjb21wb25lbnRQb3MrKykge1xuICAgIHZhciBjb21wb25lbnQgPSBjb21wb25lbnRzW2NvbXBvbmVudFBvc107XG5cbiAgICBpZiAoIWNvbXBvbmVudC5yZW1vdmVkKSB7XG4gICAgICBpZiAoIWNvbXBvbmVudC5hZGRlZCAmJiB1c2VMb25nZXN0VG9rZW4pIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbmV3U3RyaW5nLnNsaWNlKG5ld1BvcywgbmV3UG9zICsgY29tcG9uZW50LmNvdW50KTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAoZnVuY3Rpb24gKHZhbHVlLCBpKSB7XG4gICAgICAgICAgdmFyIG9sZFZhbHVlID0gb2xkU3RyaW5nW29sZFBvcyArIGldO1xuICAgICAgICAgIHJldHVybiBvbGRWYWx1ZS5sZW5ndGggPiB2YWx1ZS5sZW5ndGggPyBvbGRWYWx1ZSA6IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29tcG9uZW50LnZhbHVlID0gZGlmZi5qb2luKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBvbmVudC52YWx1ZSA9IGRpZmYuam9pbihuZXdTdHJpbmcuc2xpY2UobmV3UG9zLCBuZXdQb3MgKyBjb21wb25lbnQuY291bnQpKTtcbiAgICAgIH1cblxuICAgICAgbmV3UG9zICs9IGNvbXBvbmVudC5jb3VudDsgLy8gQ29tbW9uIGNhc2VcblxuICAgICAgaWYgKCFjb21wb25lbnQuYWRkZWQpIHtcbiAgICAgICAgb2xkUG9zICs9IGNvbXBvbmVudC5jb3VudDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9uZW50LnZhbHVlID0gZGlmZi5qb2luKG9sZFN0cmluZy5zbGljZShvbGRQb3MsIG9sZFBvcyArIGNvbXBvbmVudC5jb3VudCkpO1xuICAgICAgb2xkUG9zICs9IGNvbXBvbmVudC5jb3VudDsgLy8gUmV2ZXJzZSBhZGQgYW5kIHJlbW92ZSBzbyByZW1vdmVzIGFyZSBvdXRwdXQgZmlyc3QgdG8gbWF0Y2ggY29tbW9uIGNvbnZlbnRpb25cbiAgICAgIC8vIFRoZSBkaWZmaW5nIGFsZ29yaXRobSBpcyB0aWVkIHRvIGFkZCB0aGVuIHJlbW92ZSBvdXRwdXQgYW5kIHRoaXMgaXMgdGhlIHNpbXBsZXN0XG4gICAgICAvLyByb3V0ZSB0byBnZXQgdGhlIGRlc2lyZWQgb3V0cHV0IHdpdGggbWluaW1hbCBvdmVyaGVhZC5cblxuICAgICAgaWYgKGNvbXBvbmVudFBvcyAmJiBjb21wb25lbnRzW2NvbXBvbmVudFBvcyAtIDFdLmFkZGVkKSB7XG4gICAgICAgIHZhciB0bXAgPSBjb21wb25lbnRzW2NvbXBvbmVudFBvcyAtIDFdO1xuICAgICAgICBjb21wb25lbnRzW2NvbXBvbmVudFBvcyAtIDFdID0gY29tcG9uZW50c1tjb21wb25lbnRQb3NdO1xuICAgICAgICBjb21wb25lbnRzW2NvbXBvbmVudFBvc10gPSB0bXA7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFNwZWNpYWwgY2FzZSBoYW5kbGUgZm9yIHdoZW4gb25lIHRlcm1pbmFsIGlzIGlnbm9yZWQgKGkuZS4gd2hpdGVzcGFjZSkuXG4gIC8vIEZvciB0aGlzIGNhc2Ugd2UgbWVyZ2UgdGhlIHRlcm1pbmFsIGludG8gdGhlIHByaW9yIHN0cmluZyBhbmQgZHJvcCB0aGUgY2hhbmdlLlxuICAvLyBUaGlzIGlzIG9ubHkgYXZhaWxhYmxlIGZvciBzdHJpbmcgbW9kZS5cblxuXG4gIHZhciBmaW5hbENvbXBvbmVudCA9IGNvbXBvbmVudHNbY29tcG9uZW50TGVuIC0gMV07XG5cbiAgaWYgKGNvbXBvbmVudExlbiA+IDEgJiYgdHlwZW9mIGZpbmFsQ29tcG9uZW50LnZhbHVlID09PSAnc3RyaW5nJyAmJiAoZmluYWxDb21wb25lbnQuYWRkZWQgfHwgZmluYWxDb21wb25lbnQucmVtb3ZlZCkgJiYgZGlmZi5lcXVhbHMoJycsIGZpbmFsQ29tcG9uZW50LnZhbHVlKSkge1xuICAgIGNvbXBvbmVudHNbY29tcG9uZW50TGVuIC0gMl0udmFsdWUgKz0gZmluYWxDb21wb25lbnQudmFsdWU7XG4gICAgY29tcG9uZW50cy5wb3AoKTtcbiAgfVxuXG4gIHJldHVybiBjb21wb25lbnRzO1xufVxuXG52YXIgY2hhcmFjdGVyRGlmZiA9IG5ldyBEaWZmKCk7XG5mdW5jdGlvbiBkaWZmQ2hhcnMob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGNoYXJhY3RlckRpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlT3B0aW9ucyhvcHRpb25zLCBkZWZhdWx0cykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBkZWZhdWx0cy5jYWxsYmFjayA9IG9wdGlvbnM7XG4gIH0gZWxzZSBpZiAob3B0aW9ucykge1xuICAgIGZvciAodmFyIG5hbWUgaW4gb3B0aW9ucykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGRlZmF1bHRzW25hbWVdID0gb3B0aW9uc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVmYXVsdHM7XG59XG5cbi8vXG4vLyBSYW5nZXMgYW5kIGV4Y2VwdGlvbnM6XG4vLyBMYXRpbi0xIFN1cHBsZW1lbnQsIDAwODDigJMwMEZGXG4vLyAgLSBVKzAwRDcgIMOXIE11bHRpcGxpY2F0aW9uIHNpZ25cbi8vICAtIFUrMDBGNyAgw7cgRGl2aXNpb24gc2lnblxuLy8gTGF0aW4gRXh0ZW5kZWQtQSwgMDEwMOKAkzAxN0Zcbi8vIExhdGluIEV4dGVuZGVkLUIsIDAxODDigJMwMjRGXG4vLyBJUEEgRXh0ZW5zaW9ucywgMDI1MOKAkzAyQUZcbi8vIFNwYWNpbmcgTW9kaWZpZXIgTGV0dGVycywgMDJCMOKAkzAyRkZcbi8vICAtIFUrMDJDNyAgy4cgJiM3MTE7ICBDYXJvblxuLy8gIC0gVSswMkQ4ICDLmCAmIzcyODsgIEJyZXZlXG4vLyAgLSBVKzAyRDkgIMuZICYjNzI5OyAgRG90IEFib3ZlXG4vLyAgLSBVKzAyREEgIMuaICYjNzMwOyAgUmluZyBBYm92ZVxuLy8gIC0gVSswMkRCICDLmyAmIzczMTsgIE9nb25la1xuLy8gIC0gVSswMkRDICDLnCAmIzczMjsgIFNtYWxsIFRpbGRlXG4vLyAgLSBVKzAyREQgIMudICYjNzMzOyAgRG91YmxlIEFjdXRlIEFjY2VudFxuLy8gTGF0aW4gRXh0ZW5kZWQgQWRkaXRpb25hbCwgMUUwMOKAkzFFRkZcblxudmFyIGV4dGVuZGVkV29yZENoYXJzID0gL15bQS1aYS16XFx4QzAtXFx1MDJDNlxcdTAyQzgtXFx1MDJEN1xcdTAyREUtXFx1MDJGRlxcdTFFMDAtXFx1MUVGRl0rJC87XG52YXIgcmVXaGl0ZXNwYWNlID0gL1xcUy87XG52YXIgd29yZERpZmYgPSBuZXcgRGlmZigpO1xuXG53b3JkRGlmZi5lcXVhbHMgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5pZ25vcmVDYXNlKSB7XG4gICAgbGVmdCA9IGxlZnQudG9Mb3dlckNhc2UoKTtcbiAgICByaWdodCA9IHJpZ2h0LnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICByZXR1cm4gbGVmdCA9PT0gcmlnaHQgfHwgdGhpcy5vcHRpb25zLmlnbm9yZVdoaXRlc3BhY2UgJiYgIXJlV2hpdGVzcGFjZS50ZXN0KGxlZnQpICYmICFyZVdoaXRlc3BhY2UudGVzdChyaWdodCk7XG59O1xuXG53b3JkRGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAvLyBBbGwgd2hpdGVzcGFjZSBzeW1ib2xzIGV4Y2VwdCBuZXdsaW5lIGdyb3VwIGludG8gb25lIHRva2VuLCBlYWNoIG5ld2xpbmUgLSBpbiBzZXBhcmF0ZSB0b2tlblxuICB2YXIgdG9rZW5zID0gdmFsdWUuc3BsaXQoLyhbXlxcU1xcclxcbl0rfFsoKVtcXF17fSdcIlxcclxcbl18XFxiKS8pOyAvLyBKb2luIHRoZSBib3VuZGFyeSBzcGxpdHMgdGhhdCB3ZSBkbyBub3QgY29uc2lkZXIgdG8gYmUgYm91bmRhcmllcy4gVGhpcyBpcyBwcmltYXJpbHkgdGhlIGV4dGVuZGVkIExhdGluIGNoYXJhY3RlciBzZXQuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBhbiBlbXB0eSBzdHJpbmcgaW4gdGhlIG5leHQgZmllbGQgYW5kIHdlIGhhdmUgb25seSB3b3JkIGNoYXJzIGJlZm9yZSBhbmQgYWZ0ZXIsIG1lcmdlXG4gICAgaWYgKCF0b2tlbnNbaSArIDFdICYmIHRva2Vuc1tpICsgMl0gJiYgZXh0ZW5kZWRXb3JkQ2hhcnMudGVzdCh0b2tlbnNbaV0pICYmIGV4dGVuZGVkV29yZENoYXJzLnRlc3QodG9rZW5zW2kgKyAyXSkpIHtcbiAgICAgIHRva2Vuc1tpXSArPSB0b2tlbnNbaSArIDJdO1xuICAgICAgdG9rZW5zLnNwbGljZShpICsgMSwgMik7XG4gICAgICBpLS07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRva2Vucztcbn07XG5cbmZ1bmN0aW9uIGRpZmZXb3JkcyhvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucykge1xuICBvcHRpb25zID0gZ2VuZXJhdGVPcHRpb25zKG9wdGlvbnMsIHtcbiAgICBpZ25vcmVXaGl0ZXNwYWNlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gd29yZERpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBkaWZmV29yZHNXaXRoU3BhY2Uob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHdvcmREaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpO1xufVxuXG52YXIgbGluZURpZmYgPSBuZXcgRGlmZigpO1xuXG5saW5lRGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBpZiAodGhpcy5vcHRpb25zLnN0cmlwVHJhaWxpbmdDcikge1xuICAgIC8vIHJlbW92ZSBvbmUgXFxyIGJlZm9yZSBcXG4gdG8gbWF0Y2ggR05VIGRpZmYncyAtLXN0cmlwLXRyYWlsaW5nLWNyIGJlaGF2aW9yXG4gICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpO1xuICB9XG5cbiAgdmFyIHJldExpbmVzID0gW10sXG4gICAgICBsaW5lc0FuZE5ld2xpbmVzID0gdmFsdWUuc3BsaXQoLyhcXG58XFxyXFxuKS8pOyAvLyBJZ25vcmUgdGhlIGZpbmFsIGVtcHR5IHRva2VuIHRoYXQgb2NjdXJzIGlmIHRoZSBzdHJpbmcgZW5kcyB3aXRoIGEgbmV3IGxpbmVcblxuICBpZiAoIWxpbmVzQW5kTmV3bGluZXNbbGluZXNBbmROZXdsaW5lcy5sZW5ndGggLSAxXSkge1xuICAgIGxpbmVzQW5kTmV3bGluZXMucG9wKCk7XG4gIH0gLy8gTWVyZ2UgdGhlIGNvbnRlbnQgYW5kIGxpbmUgc2VwYXJhdG9ycyBpbnRvIHNpbmdsZSB0b2tlbnNcblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXNBbmROZXdsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsaW5lID0gbGluZXNBbmROZXdsaW5lc1tpXTtcblxuICAgIGlmIChpICUgMiAmJiAhdGhpcy5vcHRpb25zLm5ld2xpbmVJc1Rva2VuKSB7XG4gICAgICByZXRMaW5lc1tyZXRMaW5lcy5sZW5ndGggLSAxXSArPSBsaW5lO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmlnbm9yZVdoaXRlc3BhY2UpIHtcbiAgICAgICAgbGluZSA9IGxpbmUudHJpbSgpO1xuICAgICAgfVxuXG4gICAgICByZXRMaW5lcy5wdXNoKGxpbmUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXRMaW5lcztcbn07XG5cbmZ1bmN0aW9uIGRpZmZMaW5lcyhvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIGxpbmVEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIGRpZmZUcmltbWVkTGluZXMob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7XG4gIHZhciBvcHRpb25zID0gZ2VuZXJhdGVPcHRpb25zKGNhbGxiYWNrLCB7XG4gICAgaWdub3JlV2hpdGVzcGFjZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIGxpbmVEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpO1xufVxuXG52YXIgc2VudGVuY2VEaWZmID0gbmV3IERpZmYoKTtcblxuc2VudGVuY2VEaWZmLnRva2VuaXplID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5zcGxpdCgvKFxcUy4rP1suIT9dKSg/PVxccyt8JCkvKTtcbn07XG5cbmZ1bmN0aW9uIGRpZmZTZW50ZW5jZXMob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7XG4gIHJldHVybiBzZW50ZW5jZURpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spO1xufVxuXG52YXIgY3NzRGlmZiA9IG5ldyBEaWZmKCk7XG5cbmNzc0RpZmYudG9rZW5pemUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnNwbGl0KC8oW3t9OjssXXxcXHMrKS8pO1xufTtcblxuZnVuY3Rpb24gZGlmZkNzcyhvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIGNzc0RpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG52YXIgb2JqZWN0UHJvdG90eXBlVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGpzb25EaWZmID0gbmV3IERpZmYoKTsgLy8gRGlzY3JpbWluYXRlIGJldHdlZW4gdHdvIGxpbmVzIG9mIHByZXR0eS1wcmludGVkLCBzZXJpYWxpemVkIEpTT04gd2hlcmUgb25lIG9mIHRoZW0gaGFzIGFcbi8vIGRhbmdsaW5nIGNvbW1hIGFuZCB0aGUgb3RoZXIgZG9lc24ndC4gVHVybnMgb3V0IGluY2x1ZGluZyB0aGUgZGFuZ2xpbmcgY29tbWEgeWllbGRzIHRoZSBuaWNlc3Qgb3V0cHV0OlxuXG5qc29uRGlmZi51c2VMb25nZXN0VG9rZW4gPSB0cnVlO1xuanNvbkRpZmYudG9rZW5pemUgPSBsaW5lRGlmZi50b2tlbml6ZTtcblxuanNvbkRpZmYuY2FzdElucHV0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBfdGhpcyRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgdW5kZWZpbmVkUmVwbGFjZW1lbnQgPSBfdGhpcyRvcHRpb25zLnVuZGVmaW5lZFJlcGxhY2VtZW50LFxuICAgICAgX3RoaXMkb3B0aW9ucyRzdHJpbmdpID0gX3RoaXMkb3B0aW9ucy5zdHJpbmdpZnlSZXBsYWNlcixcbiAgICAgIHN0cmluZ2lmeVJlcGxhY2VyID0gX3RoaXMkb3B0aW9ucyRzdHJpbmdpID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoaywgdikge1xuICAgIHJldHVybiB0eXBlb2YgdiA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWRSZXBsYWNlbWVudCA6IHY7XG4gIH0gOiBfdGhpcyRvcHRpb25zJHN0cmluZ2k7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWUgOiBKU09OLnN0cmluZ2lmeShjYW5vbmljYWxpemUodmFsdWUsIG51bGwsIG51bGwsIHN0cmluZ2lmeVJlcGxhY2VyKSwgc3RyaW5naWZ5UmVwbGFjZXIsICcgICcpO1xufTtcblxuanNvbkRpZmYuZXF1YWxzID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gIHJldHVybiBEaWZmLnByb3RvdHlwZS5lcXVhbHMuY2FsbChqc29uRGlmZiwgbGVmdC5yZXBsYWNlKC8sKFtcXHJcXG5dKS9nLCAnJDEnKSwgcmlnaHQucmVwbGFjZSgvLChbXFxyXFxuXSkvZywgJyQxJykpO1xufTtcblxuZnVuY3Rpb24gZGlmZkpzb24ob2xkT2JqLCBuZXdPYmosIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGpzb25EaWZmLmRpZmYob2xkT2JqLCBuZXdPYmosIG9wdGlvbnMpO1xufSAvLyBUaGlzIGZ1bmN0aW9uIGhhbmRsZXMgdGhlIHByZXNlbmNlIG9mIGNpcmN1bGFyIHJlZmVyZW5jZXMgYnkgYmFpbGluZyBvdXQgd2hlbiBlbmNvdW50ZXJpbmcgYW5cbi8vIG9iamVjdCB0aGF0IGlzIGFscmVhZHkgb24gdGhlIFwic3RhY2tcIiBvZiBpdGVtcyBiZWluZyBwcm9jZXNzZWQuIEFjY2VwdHMgYW4gb3B0aW9uYWwgcmVwbGFjZXJcblxuZnVuY3Rpb24gY2Fub25pY2FsaXplKG9iaiwgc3RhY2ssIHJlcGxhY2VtZW50U3RhY2ssIHJlcGxhY2VyLCBrZXkpIHtcbiAgc3RhY2sgPSBzdGFjayB8fCBbXTtcbiAgcmVwbGFjZW1lbnRTdGFjayA9IHJlcGxhY2VtZW50U3RhY2sgfHwgW107XG5cbiAgaWYgKHJlcGxhY2VyKSB7XG4gICAgb2JqID0gcmVwbGFjZXIoa2V5LCBvYmopO1xuICB9XG5cbiAgdmFyIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKHN0YWNrW2ldID09PSBvYmopIHtcbiAgICAgIHJldHVybiByZXBsYWNlbWVudFN0YWNrW2ldO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjYW5vbmljYWxpemVkT2JqO1xuXG4gIGlmICgnW29iamVjdCBBcnJheV0nID09PSBvYmplY3RQcm90b3R5cGVUb1N0cmluZy5jYWxsKG9iaikpIHtcbiAgICBzdGFjay5wdXNoKG9iaik7XG4gICAgY2Fub25pY2FsaXplZE9iaiA9IG5ldyBBcnJheShvYmoubGVuZ3RoKTtcbiAgICByZXBsYWNlbWVudFN0YWNrLnB1c2goY2Fub25pY2FsaXplZE9iaik7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjYW5vbmljYWxpemVkT2JqW2ldID0gY2Fub25pY2FsaXplKG9ialtpXSwgc3RhY2ssIHJlcGxhY2VtZW50U3RhY2ssIHJlcGxhY2VyLCBrZXkpO1xuICAgIH1cblxuICAgIHN0YWNrLnBvcCgpO1xuICAgIHJlcGxhY2VtZW50U3RhY2sucG9wKCk7XG4gICAgcmV0dXJuIGNhbm9uaWNhbGl6ZWRPYmo7XG4gIH1cblxuICBpZiAob2JqICYmIG9iai50b0pTT04pIHtcbiAgICBvYmogPSBvYmoudG9KU09OKCk7XG4gIH1cblxuICBpZiAoX3R5cGVvZihvYmopID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwpIHtcbiAgICBzdGFjay5wdXNoKG9iaik7XG4gICAgY2Fub25pY2FsaXplZE9iaiA9IHt9O1xuICAgIHJlcGxhY2VtZW50U3RhY2sucHVzaChjYW5vbmljYWxpemVkT2JqKTtcblxuICAgIHZhciBzb3J0ZWRLZXlzID0gW10sXG4gICAgICAgIF9rZXk7XG5cbiAgICBmb3IgKF9rZXkgaW4gb2JqKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShfa2V5KSkge1xuICAgICAgICBzb3J0ZWRLZXlzLnB1c2goX2tleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc29ydGVkS2V5cy5zb3J0KCk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc29ydGVkS2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgX2tleSA9IHNvcnRlZEtleXNbaV07XG4gICAgICBjYW5vbmljYWxpemVkT2JqW19rZXldID0gY2Fub25pY2FsaXplKG9ialtfa2V5XSwgc3RhY2ssIHJlcGxhY2VtZW50U3RhY2ssIHJlcGxhY2VyLCBfa2V5KTtcbiAgICB9XG5cbiAgICBzdGFjay5wb3AoKTtcbiAgICByZXBsYWNlbWVudFN0YWNrLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIGNhbm9uaWNhbGl6ZWRPYmogPSBvYmo7XG4gIH1cblxuICByZXR1cm4gY2Fub25pY2FsaXplZE9iajtcbn1cblxudmFyIGFycmF5RGlmZiA9IG5ldyBEaWZmKCk7XG5cbmFycmF5RGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuc2xpY2UoKTtcbn07XG5cbmFycmF5RGlmZi5qb2luID0gYXJyYXlEaWZmLnJlbW92ZUVtcHR5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbmZ1bmN0aW9uIGRpZmZBcnJheXMob2xkQXJyLCBuZXdBcnIsIGNhbGxiYWNrKSB7XG4gIHJldHVybiBhcnJheURpZmYuZGlmZihvbGRBcnIsIG5ld0FyciwgY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBwYXJzZVBhdGNoKHVuaURpZmYpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIgZGlmZnN0ciA9IHVuaURpZmYuc3BsaXQoL1xcclxcbnxbXFxuXFx2XFxmXFxyXFx4ODVdLyksXG4gICAgICBkZWxpbWl0ZXJzID0gdW5pRGlmZi5tYXRjaCgvXFxyXFxufFtcXG5cXHZcXGZcXHJcXHg4NV0vZykgfHwgW10sXG4gICAgICBsaXN0ID0gW10sXG4gICAgICBpID0gMDtcblxuICBmdW5jdGlvbiBwYXJzZUluZGV4KCkge1xuICAgIHZhciBpbmRleCA9IHt9O1xuICAgIGxpc3QucHVzaChpbmRleCk7IC8vIFBhcnNlIGRpZmYgbWV0YWRhdGFcblxuICAgIHdoaWxlIChpIDwgZGlmZnN0ci5sZW5ndGgpIHtcbiAgICAgIHZhciBsaW5lID0gZGlmZnN0cltpXTsgLy8gRmlsZSBoZWFkZXIgZm91bmQsIGVuZCBwYXJzaW5nIGRpZmYgbWV0YWRhdGFcblxuICAgICAgaWYgKC9eKFxcLVxcLVxcLXxcXCtcXCtcXCt8QEApXFxzLy50ZXN0KGxpbmUpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBEaWZmIGluZGV4XG5cblxuICAgICAgdmFyIGhlYWRlciA9IC9eKD86SW5kZXg6fGRpZmYoPzogLXIgXFx3KykrKVxccysoLis/KVxccyokLy5leGVjKGxpbmUpO1xuXG4gICAgICBpZiAoaGVhZGVyKSB7XG4gICAgICAgIGluZGV4LmluZGV4ID0gaGVhZGVyWzFdO1xuICAgICAgfVxuXG4gICAgICBpKys7XG4gICAgfSAvLyBQYXJzZSBmaWxlIGhlYWRlcnMgaWYgdGhleSBhcmUgZGVmaW5lZC4gVW5pZmllZCBkaWZmIHJlcXVpcmVzIHRoZW0sIGJ1dFxuICAgIC8vIHRoZXJlJ3Mgbm8gdGVjaG5pY2FsIGlzc3VlcyB0byBoYXZlIGFuIGlzb2xhdGVkIGh1bmsgd2l0aG91dCBmaWxlIGhlYWRlclxuXG5cbiAgICBwYXJzZUZpbGVIZWFkZXIoaW5kZXgpO1xuICAgIHBhcnNlRmlsZUhlYWRlcihpbmRleCk7IC8vIFBhcnNlIGh1bmtzXG5cbiAgICBpbmRleC5odW5rcyA9IFtdO1xuXG4gICAgd2hpbGUgKGkgPCBkaWZmc3RyLmxlbmd0aCkge1xuICAgICAgdmFyIF9saW5lID0gZGlmZnN0cltpXTtcblxuICAgICAgaWYgKC9eKEluZGV4OnxkaWZmfFxcLVxcLVxcLXxcXCtcXCtcXCspXFxzLy50ZXN0KF9saW5lKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoL15AQC8udGVzdChfbGluZSkpIHtcbiAgICAgICAgaW5kZXguaHVua3MucHVzaChwYXJzZUh1bmsoKSk7XG4gICAgICB9IGVsc2UgaWYgKF9saW5lICYmIG9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICAgIC8vIElnbm9yZSB1bmV4cGVjdGVkIGNvbnRlbnQgdW5sZXNzIGluIHN0cmljdCBtb2RlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBsaW5lICcgKyAoaSArIDEpICsgJyAnICsgSlNPTi5zdHJpbmdpZnkoX2xpbmUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gUGFyc2VzIHRoZSAtLS0gYW5kICsrKyBoZWFkZXJzLCBpZiBub25lIGFyZSBmb3VuZCwgbm8gbGluZXNcbiAgLy8gYXJlIGNvbnN1bWVkLlxuXG5cbiAgZnVuY3Rpb24gcGFyc2VGaWxlSGVhZGVyKGluZGV4KSB7XG4gICAgdmFyIGZpbGVIZWFkZXIgPSAvXigtLS18XFwrXFwrXFwrKVxccysoLiopJC8uZXhlYyhkaWZmc3RyW2ldKTtcblxuICAgIGlmIChmaWxlSGVhZGVyKSB7XG4gICAgICB2YXIga2V5UHJlZml4ID0gZmlsZUhlYWRlclsxXSA9PT0gJy0tLScgPyAnb2xkJyA6ICduZXcnO1xuICAgICAgdmFyIGRhdGEgPSBmaWxlSGVhZGVyWzJdLnNwbGl0KCdcXHQnLCAyKTtcbiAgICAgIHZhciBmaWxlTmFtZSA9IGRhdGFbMF0ucmVwbGFjZSgvXFxcXFxcXFwvZywgJ1xcXFwnKTtcblxuICAgICAgaWYgKC9eXCIuKlwiJC8udGVzdChmaWxlTmFtZSkpIHtcbiAgICAgICAgZmlsZU5hbWUgPSBmaWxlTmFtZS5zdWJzdHIoMSwgZmlsZU5hbWUubGVuZ3RoIC0gMik7XG4gICAgICB9XG5cbiAgICAgIGluZGV4W2tleVByZWZpeCArICdGaWxlTmFtZSddID0gZmlsZU5hbWU7XG4gICAgICBpbmRleFtrZXlQcmVmaXggKyAnSGVhZGVyJ10gPSAoZGF0YVsxXSB8fCAnJykudHJpbSgpO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfSAvLyBQYXJzZXMgYSBodW5rXG4gIC8vIFRoaXMgYXNzdW1lcyB0aGF0IHdlIGFyZSBhdCB0aGUgc3RhcnQgb2YgYSBodW5rLlxuXG5cbiAgZnVuY3Rpb24gcGFyc2VIdW5rKCkge1xuICAgIHZhciBjaHVua0hlYWRlckluZGV4ID0gaSxcbiAgICAgICAgY2h1bmtIZWFkZXJMaW5lID0gZGlmZnN0cltpKytdLFxuICAgICAgICBjaHVua0hlYWRlciA9IGNodW5rSGVhZGVyTGluZS5zcGxpdCgvQEAgLShcXGQrKSg/OiwoXFxkKykpPyBcXCsoXFxkKykoPzosKFxcZCspKT8gQEAvKTtcbiAgICB2YXIgaHVuayA9IHtcbiAgICAgIG9sZFN0YXJ0OiArY2h1bmtIZWFkZXJbMV0sXG4gICAgICBvbGRMaW5lczogdHlwZW9mIGNodW5rSGVhZGVyWzJdID09PSAndW5kZWZpbmVkJyA/IDEgOiArY2h1bmtIZWFkZXJbMl0sXG4gICAgICBuZXdTdGFydDogK2NodW5rSGVhZGVyWzNdLFxuICAgICAgbmV3TGluZXM6IHR5cGVvZiBjaHVua0hlYWRlcls0XSA9PT0gJ3VuZGVmaW5lZCcgPyAxIDogK2NodW5rSGVhZGVyWzRdLFxuICAgICAgbGluZXM6IFtdLFxuICAgICAgbGluZWRlbGltaXRlcnM6IFtdXG4gICAgfTsgLy8gVW5pZmllZCBEaWZmIEZvcm1hdCBxdWlyazogSWYgdGhlIGNodW5rIHNpemUgaXMgMCxcbiAgICAvLyB0aGUgZmlyc3QgbnVtYmVyIGlzIG9uZSBsb3dlciB0aGFuIG9uZSB3b3VsZCBleHBlY3QuXG4gICAgLy8gaHR0cHM6Ly93d3cuYXJ0aW1hLmNvbS93ZWJsb2dzL3ZpZXdwb3N0LmpzcD90aHJlYWQ9MTY0MjkzXG5cbiAgICBpZiAoaHVuay5vbGRMaW5lcyA9PT0gMCkge1xuICAgICAgaHVuay5vbGRTdGFydCArPSAxO1xuICAgIH1cblxuICAgIGlmIChodW5rLm5ld0xpbmVzID09PSAwKSB7XG4gICAgICBodW5rLm5ld1N0YXJ0ICs9IDE7XG4gICAgfVxuXG4gICAgdmFyIGFkZENvdW50ID0gMCxcbiAgICAgICAgcmVtb3ZlQ291bnQgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBkaWZmc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBMaW5lcyBzdGFydGluZyB3aXRoICctLS0nIGNvdWxkIGJlIG1pc3Rha2VuIGZvciB0aGUgXCJyZW1vdmUgbGluZVwiIG9wZXJhdGlvblxuICAgICAgLy8gQnV0IHRoZXkgY291bGQgYmUgdGhlIGhlYWRlciBmb3IgdGhlIG5leHQgZmlsZS4gVGhlcmVmb3JlIHBydW5lIHN1Y2ggY2FzZXMgb3V0LlxuICAgICAgaWYgKGRpZmZzdHJbaV0uaW5kZXhPZignLS0tICcpID09PSAwICYmIGkgKyAyIDwgZGlmZnN0ci5sZW5ndGggJiYgZGlmZnN0cltpICsgMV0uaW5kZXhPZignKysrICcpID09PSAwICYmIGRpZmZzdHJbaSArIDJdLmluZGV4T2YoJ0BAJykgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBvcGVyYXRpb24gPSBkaWZmc3RyW2ldLmxlbmd0aCA9PSAwICYmIGkgIT0gZGlmZnN0ci5sZW5ndGggLSAxID8gJyAnIDogZGlmZnN0cltpXVswXTtcblxuICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJysnIHx8IG9wZXJhdGlvbiA9PT0gJy0nIHx8IG9wZXJhdGlvbiA9PT0gJyAnIHx8IG9wZXJhdGlvbiA9PT0gJ1xcXFwnKSB7XG4gICAgICAgIGh1bmsubGluZXMucHVzaChkaWZmc3RyW2ldKTtcbiAgICAgICAgaHVuay5saW5lZGVsaW1pdGVycy5wdXNoKGRlbGltaXRlcnNbaV0gfHwgJ1xcbicpO1xuXG4gICAgICAgIGlmIChvcGVyYXRpb24gPT09ICcrJykge1xuICAgICAgICAgIGFkZENvdW50Kys7XG4gICAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSAnLScpIHtcbiAgICAgICAgICByZW1vdmVDb3VudCsrO1xuICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gJyAnKSB7XG4gICAgICAgICAgYWRkQ291bnQrKztcbiAgICAgICAgICByZW1vdmVDb3VudCsrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IC8vIEhhbmRsZSB0aGUgZW1wdHkgYmxvY2sgY291bnQgY2FzZVxuXG5cbiAgICBpZiAoIWFkZENvdW50ICYmIGh1bmsubmV3TGluZXMgPT09IDEpIHtcbiAgICAgIGh1bmsubmV3TGluZXMgPSAwO1xuICAgIH1cblxuICAgIGlmICghcmVtb3ZlQ291bnQgJiYgaHVuay5vbGRMaW5lcyA9PT0gMSkge1xuICAgICAgaHVuay5vbGRMaW5lcyA9IDA7XG4gICAgfSAvLyBQZXJmb3JtIG9wdGlvbmFsIHNhbml0eSBjaGVja2luZ1xuXG5cbiAgICBpZiAob3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgIGlmIChhZGRDb3VudCAhPT0gaHVuay5uZXdMaW5lcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FkZGVkIGxpbmUgY291bnQgZGlkIG5vdCBtYXRjaCBmb3IgaHVuayBhdCBsaW5lICcgKyAoY2h1bmtIZWFkZXJJbmRleCArIDEpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlbW92ZUNvdW50ICE9PSBodW5rLm9sZExpbmVzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVtb3ZlZCBsaW5lIGNvdW50IGRpZCBub3QgbWF0Y2ggZm9yIGh1bmsgYXQgbGluZSAnICsgKGNodW5rSGVhZGVySW5kZXggKyAxKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGh1bms7XG4gIH1cblxuICB3aGlsZSAoaSA8IGRpZmZzdHIubGVuZ3RoKSB7XG4gICAgcGFyc2VJbmRleCgpO1xuICB9XG5cbiAgcmV0dXJuIGxpc3Q7XG59XG5cbi8vIEl0ZXJhdG9yIHRoYXQgdHJhdmVyc2VzIGluIHRoZSByYW5nZSBvZiBbbWluLCBtYXhdLCBzdGVwcGluZ1xuLy8gYnkgZGlzdGFuY2UgZnJvbSBhIGdpdmVuIHN0YXJ0IHBvc2l0aW9uLiBJLmUuIGZvciBbMCwgNF0sIHdpdGhcbi8vIHN0YXJ0IG9mIDIsIHRoaXMgd2lsbCBpdGVyYXRlIDIsIDMsIDEsIDQsIDAuXG5mdW5jdGlvbiBkaXN0YW5jZUl0ZXJhdG9yIChzdGFydCwgbWluTGluZSwgbWF4TGluZSkge1xuICB2YXIgd2FudEZvcndhcmQgPSB0cnVlLFxuICAgICAgYmFja3dhcmRFeGhhdXN0ZWQgPSBmYWxzZSxcbiAgICAgIGZvcndhcmRFeGhhdXN0ZWQgPSBmYWxzZSxcbiAgICAgIGxvY2FsT2Zmc2V0ID0gMTtcbiAgcmV0dXJuIGZ1bmN0aW9uIGl0ZXJhdG9yKCkge1xuICAgIGlmICh3YW50Rm9yd2FyZCAmJiAhZm9yd2FyZEV4aGF1c3RlZCkge1xuICAgICAgaWYgKGJhY2t3YXJkRXhoYXVzdGVkKSB7XG4gICAgICAgIGxvY2FsT2Zmc2V0Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YW50Rm9yd2FyZCA9IGZhbHNlO1xuICAgICAgfSAvLyBDaGVjayBpZiB0cnlpbmcgdG8gZml0IGJleW9uZCB0ZXh0IGxlbmd0aCwgYW5kIGlmIG5vdCwgY2hlY2sgaXQgZml0c1xuICAgICAgLy8gYWZ0ZXIgb2Zmc2V0IGxvY2F0aW9uIChvciBkZXNpcmVkIGxvY2F0aW9uIG9uIGZpcnN0IGl0ZXJhdGlvbilcblxuXG4gICAgICBpZiAoc3RhcnQgKyBsb2NhbE9mZnNldCA8PSBtYXhMaW5lKSB7XG4gICAgICAgIHJldHVybiBsb2NhbE9mZnNldDtcbiAgICAgIH1cblxuICAgICAgZm9yd2FyZEV4aGF1c3RlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCFiYWNrd2FyZEV4aGF1c3RlZCkge1xuICAgICAgaWYgKCFmb3J3YXJkRXhoYXVzdGVkKSB7XG4gICAgICAgIHdhbnRGb3J3YXJkID0gdHJ1ZTtcbiAgICAgIH0gLy8gQ2hlY2sgaWYgdHJ5aW5nIHRvIGZpdCBiZWZvcmUgdGV4dCBiZWdpbm5pbmcsIGFuZCBpZiBub3QsIGNoZWNrIGl0IGZpdHNcbiAgICAgIC8vIGJlZm9yZSBvZmZzZXQgbG9jYXRpb25cblxuXG4gICAgICBpZiAobWluTGluZSA8PSBzdGFydCAtIGxvY2FsT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiAtbG9jYWxPZmZzZXQrKztcbiAgICAgIH1cblxuICAgICAgYmFja3dhcmRFeGhhdXN0ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yKCk7XG4gICAgfSAvLyBXZSB0cmllZCB0byBmaXQgaHVuayBiZWZvcmUgdGV4dCBiZWdpbm5pbmcgYW5kIGJleW9uZCB0ZXh0IGxlbmd0aCwgdGhlblxuICAgIC8vIGh1bmsgY2FuJ3QgZml0IG9uIHRoZSB0ZXh0LiBSZXR1cm4gdW5kZWZpbmVkXG5cbiAgfTtcbn1cblxuZnVuY3Rpb24gYXBwbHlQYXRjaChzb3VyY2UsIHVuaURpZmYpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gIGlmICh0eXBlb2YgdW5pRGlmZiA9PT0gJ3N0cmluZycpIHtcbiAgICB1bmlEaWZmID0gcGFyc2VQYXRjaCh1bmlEaWZmKTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHVuaURpZmYpKSB7XG4gICAgaWYgKHVuaURpZmYubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcHBseVBhdGNoIG9ubHkgd29ya3Mgd2l0aCBhIHNpbmdsZSBpbnB1dC4nKTtcbiAgICB9XG5cbiAgICB1bmlEaWZmID0gdW5pRGlmZlswXTtcbiAgfSAvLyBBcHBseSB0aGUgZGlmZiB0byB0aGUgaW5wdXRcblxuXG4gIHZhciBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvXFxyXFxufFtcXG5cXHZcXGZcXHJcXHg4NV0vKSxcbiAgICAgIGRlbGltaXRlcnMgPSBzb3VyY2UubWF0Y2goL1xcclxcbnxbXFxuXFx2XFxmXFxyXFx4ODVdL2cpIHx8IFtdLFxuICAgICAgaHVua3MgPSB1bmlEaWZmLmh1bmtzLFxuICAgICAgY29tcGFyZUxpbmUgPSBvcHRpb25zLmNvbXBhcmVMaW5lIHx8IGZ1bmN0aW9uIChsaW5lTnVtYmVyLCBsaW5lLCBvcGVyYXRpb24sIHBhdGNoQ29udGVudCkge1xuICAgIHJldHVybiBsaW5lID09PSBwYXRjaENvbnRlbnQ7XG4gIH0sXG4gICAgICBlcnJvckNvdW50ID0gMCxcbiAgICAgIGZ1enpGYWN0b3IgPSBvcHRpb25zLmZ1enpGYWN0b3IgfHwgMCxcbiAgICAgIG1pbkxpbmUgPSAwLFxuICAgICAgb2Zmc2V0ID0gMCxcbiAgICAgIHJlbW92ZUVPRk5MLFxuICAgICAgYWRkRU9GTkw7XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGh1bmsgZXhhY3RseSBmaXRzIG9uIHRoZSBwcm92aWRlZCBsb2NhdGlvblxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGh1bmtGaXRzKGh1bmssIHRvUG9zKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBodW5rLmxpbmVzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgbGluZSA9IGh1bmsubGluZXNbal0sXG4gICAgICAgICAgb3BlcmF0aW9uID0gbGluZS5sZW5ndGggPiAwID8gbGluZVswXSA6ICcgJyxcbiAgICAgICAgICBjb250ZW50ID0gbGluZS5sZW5ndGggPiAwID8gbGluZS5zdWJzdHIoMSkgOiBsaW5lO1xuXG4gICAgICBpZiAob3BlcmF0aW9uID09PSAnICcgfHwgb3BlcmF0aW9uID09PSAnLScpIHtcbiAgICAgICAgLy8gQ29udGV4dCBzYW5pdHkgY2hlY2tcbiAgICAgICAgaWYgKCFjb21wYXJlTGluZSh0b1BvcyArIDEsIGxpbmVzW3RvUG9zXSwgb3BlcmF0aW9uLCBjb250ZW50KSkge1xuICAgICAgICAgIGVycm9yQ291bnQrKztcblxuICAgICAgICAgIGlmIChlcnJvckNvdW50ID4gZnV6ekZhY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRvUG9zKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gU2VhcmNoIGJlc3QgZml0IG9mZnNldHMgZm9yIGVhY2ggaHVuayBiYXNlZCBvbiB0aGUgcHJldmlvdXMgb25lc1xuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBodW5rcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBodW5rID0gaHVua3NbaV0sXG4gICAgICAgIG1heExpbmUgPSBsaW5lcy5sZW5ndGggLSBodW5rLm9sZExpbmVzLFxuICAgICAgICBsb2NhbE9mZnNldCA9IDAsXG4gICAgICAgIHRvUG9zID0gb2Zmc2V0ICsgaHVuay5vbGRTdGFydCAtIDE7XG4gICAgdmFyIGl0ZXJhdG9yID0gZGlzdGFuY2VJdGVyYXRvcih0b1BvcywgbWluTGluZSwgbWF4TGluZSk7XG5cbiAgICBmb3IgKDsgbG9jYWxPZmZzZXQgIT09IHVuZGVmaW5lZDsgbG9jYWxPZmZzZXQgPSBpdGVyYXRvcigpKSB7XG4gICAgICBpZiAoaHVua0ZpdHMoaHVuaywgdG9Qb3MgKyBsb2NhbE9mZnNldCkpIHtcbiAgICAgICAgaHVuay5vZmZzZXQgPSBvZmZzZXQgKz0gbG9jYWxPZmZzZXQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsb2NhbE9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBTZXQgbG93ZXIgdGV4dCBsaW1pdCB0byBlbmQgb2YgdGhlIGN1cnJlbnQgaHVuaywgc28gbmV4dCBvbmVzIGRvbid0IHRyeVxuICAgIC8vIHRvIGZpdCBvdmVyIGFscmVhZHkgcGF0Y2hlZCB0ZXh0XG5cblxuICAgIG1pbkxpbmUgPSBodW5rLm9mZnNldCArIGh1bmsub2xkU3RhcnQgKyBodW5rLm9sZExpbmVzO1xuICB9IC8vIEFwcGx5IHBhdGNoIGh1bmtzXG5cblxuICB2YXIgZGlmZk9mZnNldCA9IDA7XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGh1bmtzLmxlbmd0aDsgX2krKykge1xuICAgIHZhciBfaHVuayA9IGh1bmtzW19pXSxcbiAgICAgICAgX3RvUG9zID0gX2h1bmsub2xkU3RhcnQgKyBfaHVuay5vZmZzZXQgKyBkaWZmT2Zmc2V0IC0gMTtcblxuICAgIGRpZmZPZmZzZXQgKz0gX2h1bmsubmV3TGluZXMgLSBfaHVuay5vbGRMaW5lcztcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgX2h1bmsubGluZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBsaW5lID0gX2h1bmsubGluZXNbal0sXG4gICAgICAgICAgb3BlcmF0aW9uID0gbGluZS5sZW5ndGggPiAwID8gbGluZVswXSA6ICcgJyxcbiAgICAgICAgICBjb250ZW50ID0gbGluZS5sZW5ndGggPiAwID8gbGluZS5zdWJzdHIoMSkgOiBsaW5lLFxuICAgICAgICAgIGRlbGltaXRlciA9IF9odW5rLmxpbmVkZWxpbWl0ZXJzICYmIF9odW5rLmxpbmVkZWxpbWl0ZXJzW2pdIHx8ICdcXG4nO1xuXG4gICAgICBpZiAob3BlcmF0aW9uID09PSAnICcpIHtcbiAgICAgICAgX3RvUG9zKys7XG4gICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gJy0nKSB7XG4gICAgICAgIGxpbmVzLnNwbGljZShfdG9Qb3MsIDEpO1xuICAgICAgICBkZWxpbWl0ZXJzLnNwbGljZShfdG9Qb3MsIDEpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICcrJykge1xuICAgICAgICBsaW5lcy5zcGxpY2UoX3RvUG9zLCAwLCBjb250ZW50KTtcbiAgICAgICAgZGVsaW1pdGVycy5zcGxpY2UoX3RvUG9zLCAwLCBkZWxpbWl0ZXIpO1xuICAgICAgICBfdG9Qb3MrKztcbiAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSAnXFxcXCcpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzT3BlcmF0aW9uID0gX2h1bmsubGluZXNbaiAtIDFdID8gX2h1bmsubGluZXNbaiAtIDFdWzBdIDogbnVsbDtcblxuICAgICAgICBpZiAocHJldmlvdXNPcGVyYXRpb24gPT09ICcrJykge1xuICAgICAgICAgIHJlbW92ZUVPRk5MID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmV2aW91c09wZXJhdGlvbiA9PT0gJy0nKSB7XG4gICAgICAgICAgYWRkRU9GTkwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIEhhbmRsZSBFT0ZOTCBpbnNlcnRpb24vcmVtb3ZhbFxuXG5cbiAgaWYgKHJlbW92ZUVPRk5MKSB7XG4gICAgd2hpbGUgKCFsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSkge1xuICAgICAgbGluZXMucG9wKCk7XG4gICAgICBkZWxpbWl0ZXJzLnBvcCgpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhZGRFT0ZOTCkge1xuICAgIGxpbmVzLnB1c2goJycpO1xuICAgIGRlbGltaXRlcnMucHVzaCgnXFxuJyk7XG4gIH1cblxuICBmb3IgKHZhciBfayA9IDA7IF9rIDwgbGluZXMubGVuZ3RoIC0gMTsgX2srKykge1xuICAgIGxpbmVzW19rXSA9IGxpbmVzW19rXSArIGRlbGltaXRlcnNbX2tdO1xuICB9XG5cbiAgcmV0dXJuIGxpbmVzLmpvaW4oJycpO1xufSAvLyBXcmFwcGVyIHRoYXQgc3VwcG9ydHMgbXVsdGlwbGUgZmlsZSBwYXRjaGVzIHZpYSBjYWxsYmFja3MuXG5cbmZ1bmN0aW9uIGFwcGx5UGF0Y2hlcyh1bmlEaWZmLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgdW5pRGlmZiA9PT0gJ3N0cmluZycpIHtcbiAgICB1bmlEaWZmID0gcGFyc2VQYXRjaCh1bmlEaWZmKTtcbiAgfVxuXG4gIHZhciBjdXJyZW50SW5kZXggPSAwO1xuXG4gIGZ1bmN0aW9uIHByb2Nlc3NJbmRleCgpIHtcbiAgICB2YXIgaW5kZXggPSB1bmlEaWZmW2N1cnJlbnRJbmRleCsrXTtcblxuICAgIGlmICghaW5kZXgpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5sb2FkRmlsZShpbmRleCwgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5jb21wbGV0ZShlcnIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdXBkYXRlZENvbnRlbnQgPSBhcHBseVBhdGNoKGRhdGEsIGluZGV4LCBvcHRpb25zKTtcbiAgICAgIG9wdGlvbnMucGF0Y2hlZChpbmRleCwgdXBkYXRlZENvbnRlbnQsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBvcHRpb25zLmNvbXBsZXRlKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9jZXNzSW5kZXgoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcHJvY2Vzc0luZGV4KCk7XG59XG5cbmZ1bmN0aW9uIHN0cnVjdHVyZWRQYXRjaChvbGRGaWxlTmFtZSwgbmV3RmlsZU5hbWUsIG9sZFN0ciwgbmV3U3RyLCBvbGRIZWFkZXIsIG5ld0hlYWRlciwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMuY29udGV4dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvcHRpb25zLmNvbnRleHQgPSA0O1xuICB9XG5cbiAgdmFyIGRpZmYgPSBkaWZmTGluZXMob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpO1xuXG4gIGlmICghZGlmZikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGRpZmYucHVzaCh7XG4gICAgdmFsdWU6ICcnLFxuICAgIGxpbmVzOiBbXVxuICB9KTsgLy8gQXBwZW5kIGFuIGVtcHR5IHZhbHVlIHRvIG1ha2UgY2xlYW51cCBlYXNpZXJcblxuICBmdW5jdGlvbiBjb250ZXh0TGluZXMobGluZXMpIHtcbiAgICByZXR1cm4gbGluZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgcmV0dXJuICcgJyArIGVudHJ5O1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGh1bmtzID0gW107XG4gIHZhciBvbGRSYW5nZVN0YXJ0ID0gMCxcbiAgICAgIG5ld1JhbmdlU3RhcnQgPSAwLFxuICAgICAgY3VyUmFuZ2UgPSBbXSxcbiAgICAgIG9sZExpbmUgPSAxLFxuICAgICAgbmV3TGluZSA9IDE7XG5cbiAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSkge1xuICAgIHZhciBjdXJyZW50ID0gZGlmZltpXSxcbiAgICAgICAgbGluZXMgPSBjdXJyZW50LmxpbmVzIHx8IGN1cnJlbnQudmFsdWUucmVwbGFjZSgvXFxuJC8sICcnKS5zcGxpdCgnXFxuJyk7XG4gICAgY3VycmVudC5saW5lcyA9IGxpbmVzO1xuXG4gICAgaWYgKGN1cnJlbnQuYWRkZWQgfHwgY3VycmVudC5yZW1vdmVkKSB7XG4gICAgICB2YXIgX2N1clJhbmdlO1xuXG4gICAgICAvLyBJZiB3ZSBoYXZlIHByZXZpb3VzIGNvbnRleHQsIHN0YXJ0IHdpdGggdGhhdFxuICAgICAgaWYgKCFvbGRSYW5nZVN0YXJ0KSB7XG4gICAgICAgIHZhciBwcmV2ID0gZGlmZltpIC0gMV07XG4gICAgICAgIG9sZFJhbmdlU3RhcnQgPSBvbGRMaW5lO1xuICAgICAgICBuZXdSYW5nZVN0YXJ0ID0gbmV3TGluZTtcblxuICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgIGN1clJhbmdlID0gb3B0aW9ucy5jb250ZXh0ID4gMCA/IGNvbnRleHRMaW5lcyhwcmV2LmxpbmVzLnNsaWNlKC1vcHRpb25zLmNvbnRleHQpKSA6IFtdO1xuICAgICAgICAgIG9sZFJhbmdlU3RhcnQgLT0gY3VyUmFuZ2UubGVuZ3RoO1xuICAgICAgICAgIG5ld1JhbmdlU3RhcnQgLT0gY3VyUmFuZ2UubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9IC8vIE91dHB1dCBvdXIgY2hhbmdlc1xuXG5cbiAgICAgIChfY3VyUmFuZ2UgPSBjdXJSYW5nZSkucHVzaC5hcHBseShfY3VyUmFuZ2UsIF90b0NvbnN1bWFibGVBcnJheShsaW5lcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIHJldHVybiAoY3VycmVudC5hZGRlZCA/ICcrJyA6ICctJykgKyBlbnRyeTtcbiAgICAgIH0pKSk7IC8vIFRyYWNrIHRoZSB1cGRhdGVkIGZpbGUgcG9zaXRpb25cblxuXG4gICAgICBpZiAoY3VycmVudC5hZGRlZCkge1xuICAgICAgICBuZXdMaW5lICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9sZExpbmUgKz0gbGluZXMubGVuZ3RoO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZGVudGljYWwgY29udGV4dCBsaW5lcy4gVHJhY2sgbGluZSBjaGFuZ2VzXG4gICAgICBpZiAob2xkUmFuZ2VTdGFydCkge1xuICAgICAgICAvLyBDbG9zZSBvdXQgYW55IGNoYW5nZXMgdGhhdCBoYXZlIGJlZW4gb3V0cHV0IChvciBqb2luIG92ZXJsYXBwaW5nKVxuICAgICAgICBpZiAobGluZXMubGVuZ3RoIDw9IG9wdGlvbnMuY29udGV4dCAqIDIgJiYgaSA8IGRpZmYubGVuZ3RoIC0gMikge1xuICAgICAgICAgIHZhciBfY3VyUmFuZ2UyO1xuXG4gICAgICAgICAgLy8gT3ZlcmxhcHBpbmdcbiAgICAgICAgICAoX2N1clJhbmdlMiA9IGN1clJhbmdlKS5wdXNoLmFwcGx5KF9jdXJSYW5nZTIsIF90b0NvbnN1bWFibGVBcnJheShjb250ZXh0TGluZXMobGluZXMpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9jdXJSYW5nZTM7XG5cbiAgICAgICAgICAvLyBlbmQgdGhlIHJhbmdlIGFuZCBvdXRwdXRcbiAgICAgICAgICB2YXIgY29udGV4dFNpemUgPSBNYXRoLm1pbihsaW5lcy5sZW5ndGgsIG9wdGlvbnMuY29udGV4dCk7XG5cbiAgICAgICAgICAoX2N1clJhbmdlMyA9IGN1clJhbmdlKS5wdXNoLmFwcGx5KF9jdXJSYW5nZTMsIF90b0NvbnN1bWFibGVBcnJheShjb250ZXh0TGluZXMobGluZXMuc2xpY2UoMCwgY29udGV4dFNpemUpKSkpO1xuXG4gICAgICAgICAgdmFyIGh1bmsgPSB7XG4gICAgICAgICAgICBvbGRTdGFydDogb2xkUmFuZ2VTdGFydCxcbiAgICAgICAgICAgIG9sZExpbmVzOiBvbGRMaW5lIC0gb2xkUmFuZ2VTdGFydCArIGNvbnRleHRTaXplLFxuICAgICAgICAgICAgbmV3U3RhcnQ6IG5ld1JhbmdlU3RhcnQsXG4gICAgICAgICAgICBuZXdMaW5lczogbmV3TGluZSAtIG5ld1JhbmdlU3RhcnQgKyBjb250ZXh0U2l6ZSxcbiAgICAgICAgICAgIGxpbmVzOiBjdXJSYW5nZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAoaSA+PSBkaWZmLmxlbmd0aCAtIDIgJiYgbGluZXMubGVuZ3RoIDw9IG9wdGlvbnMuY29udGV4dCkge1xuICAgICAgICAgICAgLy8gRU9GIGlzIGluc2lkZSB0aGlzIGh1bmtcbiAgICAgICAgICAgIHZhciBvbGRFT0ZOZXdsaW5lID0gL1xcbiQvLnRlc3Qob2xkU3RyKTtcbiAgICAgICAgICAgIHZhciBuZXdFT0ZOZXdsaW5lID0gL1xcbiQvLnRlc3QobmV3U3RyKTtcbiAgICAgICAgICAgIHZhciBub05sQmVmb3JlQWRkcyA9IGxpbmVzLmxlbmd0aCA9PSAwICYmIGN1clJhbmdlLmxlbmd0aCA+IGh1bmsub2xkTGluZXM7XG5cbiAgICAgICAgICAgIGlmICghb2xkRU9GTmV3bGluZSAmJiBub05sQmVmb3JlQWRkcyAmJiBvbGRTdHIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2U6IG9sZCBoYXMgbm8gZW9sIGFuZCBubyB0cmFpbGluZyBjb250ZXh0OyBuby1ubCBjYW4gZW5kIHVwIGJlZm9yZSBhZGRzXG4gICAgICAgICAgICAgIC8vIGhvd2V2ZXIsIGlmIHRoZSBvbGQgZmlsZSBpcyBlbXB0eSwgZG8gbm90IG91dHB1dCB0aGUgbm8tbmwgbGluZVxuICAgICAgICAgICAgICBjdXJSYW5nZS5zcGxpY2UoaHVuay5vbGRMaW5lcywgMCwgJ1xcXFwgTm8gbmV3bGluZSBhdCBlbmQgb2YgZmlsZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW9sZEVPRk5ld2xpbmUgJiYgIW5vTmxCZWZvcmVBZGRzIHx8ICFuZXdFT0ZOZXdsaW5lKSB7XG4gICAgICAgICAgICAgIGN1clJhbmdlLnB1c2goJ1xcXFwgTm8gbmV3bGluZSBhdCBlbmQgb2YgZmlsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGh1bmtzLnB1c2goaHVuayk7XG4gICAgICAgICAgb2xkUmFuZ2VTdGFydCA9IDA7XG4gICAgICAgICAgbmV3UmFuZ2VTdGFydCA9IDA7XG4gICAgICAgICAgY3VyUmFuZ2UgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvbGRMaW5lICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgIG5ld0xpbmUgKz0gbGluZXMubGVuZ3RoO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRpZmYubGVuZ3RoOyBpKyspIHtcbiAgICBfbG9vcChpKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb2xkRmlsZU5hbWU6IG9sZEZpbGVOYW1lLFxuICAgIG5ld0ZpbGVOYW1lOiBuZXdGaWxlTmFtZSxcbiAgICBvbGRIZWFkZXI6IG9sZEhlYWRlcixcbiAgICBuZXdIZWFkZXI6IG5ld0hlYWRlcixcbiAgICBodW5rczogaHVua3NcbiAgfTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFBhdGNoKGRpZmYpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGlmZikpIHtcbiAgICByZXR1cm4gZGlmZi5tYXAoZm9ybWF0UGF0Y2gpLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgdmFyIHJldCA9IFtdO1xuXG4gIGlmIChkaWZmLm9sZEZpbGVOYW1lID09IGRpZmYubmV3RmlsZU5hbWUpIHtcbiAgICByZXQucHVzaCgnSW5kZXg6ICcgKyBkaWZmLm9sZEZpbGVOYW1lKTtcbiAgfVxuXG4gIHJldC5wdXNoKCc9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Jyk7XG4gIHJldC5wdXNoKCctLS0gJyArIGRpZmYub2xkRmlsZU5hbWUgKyAodHlwZW9mIGRpZmYub2xkSGVhZGVyID09PSAndW5kZWZpbmVkJyA/ICcnIDogJ1xcdCcgKyBkaWZmLm9sZEhlYWRlcikpO1xuICByZXQucHVzaCgnKysrICcgKyBkaWZmLm5ld0ZpbGVOYW1lICsgKHR5cGVvZiBkaWZmLm5ld0hlYWRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6ICdcXHQnICsgZGlmZi5uZXdIZWFkZXIpKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRpZmYuaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaHVuayA9IGRpZmYuaHVua3NbaV07IC8vIFVuaWZpZWQgRGlmZiBGb3JtYXQgcXVpcms6IElmIHRoZSBjaHVuayBzaXplIGlzIDAsXG4gICAgLy8gdGhlIGZpcnN0IG51bWJlciBpcyBvbmUgbG93ZXIgdGhhbiBvbmUgd291bGQgZXhwZWN0LlxuICAgIC8vIGh0dHBzOi8vd3d3LmFydGltYS5jb20vd2VibG9ncy92aWV3cG9zdC5qc3A/dGhyZWFkPTE2NDI5M1xuXG4gICAgaWYgKGh1bmsub2xkTGluZXMgPT09IDApIHtcbiAgICAgIGh1bmsub2xkU3RhcnQgLT0gMTtcbiAgICB9XG5cbiAgICBpZiAoaHVuay5uZXdMaW5lcyA9PT0gMCkge1xuICAgICAgaHVuay5uZXdTdGFydCAtPSAxO1xuICAgIH1cblxuICAgIHJldC5wdXNoKCdAQCAtJyArIGh1bmsub2xkU3RhcnQgKyAnLCcgKyBodW5rLm9sZExpbmVzICsgJyArJyArIGh1bmsubmV3U3RhcnQgKyAnLCcgKyBodW5rLm5ld0xpbmVzICsgJyBAQCcpO1xuICAgIHJldC5wdXNoLmFwcGx5KHJldCwgaHVuay5saW5lcyk7XG4gIH1cblxuICByZXR1cm4gcmV0LmpvaW4oJ1xcbicpICsgJ1xcbic7XG59XG5mdW5jdGlvbiBjcmVhdGVUd29GaWxlc1BhdGNoKG9sZEZpbGVOYW1lLCBuZXdGaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKSB7XG4gIHJldHVybiBmb3JtYXRQYXRjaChzdHJ1Y3R1cmVkUGF0Y2gob2xkRmlsZU5hbWUsIG5ld0ZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhdGNoKGZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGNyZWF0ZVR3b0ZpbGVzUGF0Y2goZmlsZU5hbWUsIGZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBhcnJheUVxdWFsKGEsIGIpIHtcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBhcnJheVN0YXJ0c1dpdGgoYSwgYik7XG59XG5mdW5jdGlvbiBhcnJheVN0YXJ0c1dpdGgoYXJyYXksIHN0YXJ0KSB7XG4gIGlmIChzdGFydC5sZW5ndGggPiBhcnJheS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0YXJ0W2ldICE9PSBhcnJheVtpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjYWxjTGluZUNvdW50KGh1bmspIHtcbiAgdmFyIF9jYWxjT2xkTmV3TGluZUNvdW50ID0gY2FsY09sZE5ld0xpbmVDb3VudChodW5rLmxpbmVzKSxcbiAgICAgIG9sZExpbmVzID0gX2NhbGNPbGROZXdMaW5lQ291bnQub2xkTGluZXMsXG4gICAgICBuZXdMaW5lcyA9IF9jYWxjT2xkTmV3TGluZUNvdW50Lm5ld0xpbmVzO1xuXG4gIGlmIChvbGRMaW5lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaHVuay5vbGRMaW5lcyA9IG9sZExpbmVzO1xuICB9IGVsc2Uge1xuICAgIGRlbGV0ZSBodW5rLm9sZExpbmVzO1xuICB9XG5cbiAgaWYgKG5ld0xpbmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBodW5rLm5ld0xpbmVzID0gbmV3TGluZXM7XG4gIH0gZWxzZSB7XG4gICAgZGVsZXRlIGh1bmsubmV3TGluZXM7XG4gIH1cbn1cbmZ1bmN0aW9uIG1lcmdlKG1pbmUsIHRoZWlycywgYmFzZSkge1xuICBtaW5lID0gbG9hZFBhdGNoKG1pbmUsIGJhc2UpO1xuICB0aGVpcnMgPSBsb2FkUGF0Y2godGhlaXJzLCBiYXNlKTtcbiAgdmFyIHJldCA9IHt9OyAvLyBGb3IgaW5kZXggd2UganVzdCBsZXQgaXQgcGFzcyB0aHJvdWdoIGFzIGl0IGRvZXNuJ3QgaGF2ZSBhbnkgbmVjZXNzYXJ5IG1lYW5pbmcuXG4gIC8vIExlYXZpbmcgc2FuaXR5IGNoZWNrcyBvbiB0aGlzIHRvIHRoZSBBUEkgY29uc3VtZXIgdGhhdCBtYXkga25vdyBtb3JlIGFib3V0IHRoZVxuICAvLyBtZWFuaW5nIGluIHRoZWlyIG93biBjb250ZXh0LlxuXG4gIGlmIChtaW5lLmluZGV4IHx8IHRoZWlycy5pbmRleCkge1xuICAgIHJldC5pbmRleCA9IG1pbmUuaW5kZXggfHwgdGhlaXJzLmluZGV4O1xuICB9XG5cbiAgaWYgKG1pbmUubmV3RmlsZU5hbWUgfHwgdGhlaXJzLm5ld0ZpbGVOYW1lKSB7XG4gICAgaWYgKCFmaWxlTmFtZUNoYW5nZWQobWluZSkpIHtcbiAgICAgIC8vIE5vIGhlYWRlciBvciBubyBjaGFuZ2UgaW4gb3VycywgdXNlIHRoZWlycyAoYW5kIG91cnMgaWYgdGhlaXJzIGRvZXMgbm90IGV4aXN0KVxuICAgICAgcmV0Lm9sZEZpbGVOYW1lID0gdGhlaXJzLm9sZEZpbGVOYW1lIHx8IG1pbmUub2xkRmlsZU5hbWU7XG4gICAgICByZXQubmV3RmlsZU5hbWUgPSB0aGVpcnMubmV3RmlsZU5hbWUgfHwgbWluZS5uZXdGaWxlTmFtZTtcbiAgICAgIHJldC5vbGRIZWFkZXIgPSB0aGVpcnMub2xkSGVhZGVyIHx8IG1pbmUub2xkSGVhZGVyO1xuICAgICAgcmV0Lm5ld0hlYWRlciA9IHRoZWlycy5uZXdIZWFkZXIgfHwgbWluZS5uZXdIZWFkZXI7XG4gICAgfSBlbHNlIGlmICghZmlsZU5hbWVDaGFuZ2VkKHRoZWlycykpIHtcbiAgICAgIC8vIE5vIGhlYWRlciBvciBubyBjaGFuZ2UgaW4gdGhlaXJzLCB1c2Ugb3Vyc1xuICAgICAgcmV0Lm9sZEZpbGVOYW1lID0gbWluZS5vbGRGaWxlTmFtZTtcbiAgICAgIHJldC5uZXdGaWxlTmFtZSA9IG1pbmUubmV3RmlsZU5hbWU7XG4gICAgICByZXQub2xkSGVhZGVyID0gbWluZS5vbGRIZWFkZXI7XG4gICAgICByZXQubmV3SGVhZGVyID0gbWluZS5uZXdIZWFkZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEJvdGggY2hhbmdlZC4uLiBmaWd1cmUgaXQgb3V0XG4gICAgICByZXQub2xkRmlsZU5hbWUgPSBzZWxlY3RGaWVsZChyZXQsIG1pbmUub2xkRmlsZU5hbWUsIHRoZWlycy5vbGRGaWxlTmFtZSk7XG4gICAgICByZXQubmV3RmlsZU5hbWUgPSBzZWxlY3RGaWVsZChyZXQsIG1pbmUubmV3RmlsZU5hbWUsIHRoZWlycy5uZXdGaWxlTmFtZSk7XG4gICAgICByZXQub2xkSGVhZGVyID0gc2VsZWN0RmllbGQocmV0LCBtaW5lLm9sZEhlYWRlciwgdGhlaXJzLm9sZEhlYWRlcik7XG4gICAgICByZXQubmV3SGVhZGVyID0gc2VsZWN0RmllbGQocmV0LCBtaW5lLm5ld0hlYWRlciwgdGhlaXJzLm5ld0hlYWRlcik7XG4gICAgfVxuICB9XG5cbiAgcmV0Lmh1bmtzID0gW107XG4gIHZhciBtaW5lSW5kZXggPSAwLFxuICAgICAgdGhlaXJzSW5kZXggPSAwLFxuICAgICAgbWluZU9mZnNldCA9IDAsXG4gICAgICB0aGVpcnNPZmZzZXQgPSAwO1xuXG4gIHdoaWxlIChtaW5lSW5kZXggPCBtaW5lLmh1bmtzLmxlbmd0aCB8fCB0aGVpcnNJbmRleCA8IHRoZWlycy5odW5rcy5sZW5ndGgpIHtcbiAgICB2YXIgbWluZUN1cnJlbnQgPSBtaW5lLmh1bmtzW21pbmVJbmRleF0gfHwge1xuICAgICAgb2xkU3RhcnQ6IEluZmluaXR5XG4gICAgfSxcbiAgICAgICAgdGhlaXJzQ3VycmVudCA9IHRoZWlycy5odW5rc1t0aGVpcnNJbmRleF0gfHwge1xuICAgICAgb2xkU3RhcnQ6IEluZmluaXR5XG4gICAgfTtcblxuICAgIGlmIChodW5rQmVmb3JlKG1pbmVDdXJyZW50LCB0aGVpcnNDdXJyZW50KSkge1xuICAgICAgLy8gVGhpcyBwYXRjaCBkb2VzIG5vdCBvdmVybGFwIHdpdGggYW55IG9mIHRoZSBvdGhlcnMsIHlheS5cbiAgICAgIHJldC5odW5rcy5wdXNoKGNsb25lSHVuayhtaW5lQ3VycmVudCwgbWluZU9mZnNldCkpO1xuICAgICAgbWluZUluZGV4Kys7XG4gICAgICB0aGVpcnNPZmZzZXQgKz0gbWluZUN1cnJlbnQubmV3TGluZXMgLSBtaW5lQ3VycmVudC5vbGRMaW5lcztcbiAgICB9IGVsc2UgaWYgKGh1bmtCZWZvcmUodGhlaXJzQ3VycmVudCwgbWluZUN1cnJlbnQpKSB7XG4gICAgICAvLyBUaGlzIHBhdGNoIGRvZXMgbm90IG92ZXJsYXAgd2l0aCBhbnkgb2YgdGhlIG90aGVycywgeWF5LlxuICAgICAgcmV0Lmh1bmtzLnB1c2goY2xvbmVIdW5rKHRoZWlyc0N1cnJlbnQsIHRoZWlyc09mZnNldCkpO1xuICAgICAgdGhlaXJzSW5kZXgrKztcbiAgICAgIG1pbmVPZmZzZXQgKz0gdGhlaXJzQ3VycmVudC5uZXdMaW5lcyAtIHRoZWlyc0N1cnJlbnQub2xkTGluZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE92ZXJsYXAsIG1lcmdlIGFzIGJlc3Qgd2UgY2FuXG4gICAgICB2YXIgbWVyZ2VkSHVuayA9IHtcbiAgICAgICAgb2xkU3RhcnQ6IE1hdGgubWluKG1pbmVDdXJyZW50Lm9sZFN0YXJ0LCB0aGVpcnNDdXJyZW50Lm9sZFN0YXJ0KSxcbiAgICAgICAgb2xkTGluZXM6IDAsXG4gICAgICAgIG5ld1N0YXJ0OiBNYXRoLm1pbihtaW5lQ3VycmVudC5uZXdTdGFydCArIG1pbmVPZmZzZXQsIHRoZWlyc0N1cnJlbnQub2xkU3RhcnQgKyB0aGVpcnNPZmZzZXQpLFxuICAgICAgICBuZXdMaW5lczogMCxcbiAgICAgICAgbGluZXM6IFtdXG4gICAgICB9O1xuICAgICAgbWVyZ2VMaW5lcyhtZXJnZWRIdW5rLCBtaW5lQ3VycmVudC5vbGRTdGFydCwgbWluZUN1cnJlbnQubGluZXMsIHRoZWlyc0N1cnJlbnQub2xkU3RhcnQsIHRoZWlyc0N1cnJlbnQubGluZXMpO1xuICAgICAgdGhlaXJzSW5kZXgrKztcbiAgICAgIG1pbmVJbmRleCsrO1xuICAgICAgcmV0Lmh1bmtzLnB1c2gobWVyZ2VkSHVuayk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gbG9hZFBhdGNoKHBhcmFtLCBiYXNlKSB7XG4gIGlmICh0eXBlb2YgcGFyYW0gPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKC9eQEAvbS50ZXN0KHBhcmFtKSB8fCAvXkluZGV4Oi9tLnRlc3QocGFyYW0pKSB7XG4gICAgICByZXR1cm4gcGFyc2VQYXRjaChwYXJhbSlbMF07XG4gICAgfVxuXG4gICAgaWYgKCFiYXNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSBhIGJhc2UgcmVmZXJlbmNlIG9yIHBhc3MgaW4gYSBwYXRjaCcpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJ1Y3R1cmVkUGF0Y2godW5kZWZpbmVkLCB1bmRlZmluZWQsIGJhc2UsIHBhcmFtKTtcbiAgfVxuXG4gIHJldHVybiBwYXJhbTtcbn1cblxuZnVuY3Rpb24gZmlsZU5hbWVDaGFuZ2VkKHBhdGNoKSB7XG4gIHJldHVybiBwYXRjaC5uZXdGaWxlTmFtZSAmJiBwYXRjaC5uZXdGaWxlTmFtZSAhPT0gcGF0Y2gub2xkRmlsZU5hbWU7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdEZpZWxkKGluZGV4LCBtaW5lLCB0aGVpcnMpIHtcbiAgaWYgKG1pbmUgPT09IHRoZWlycykge1xuICAgIHJldHVybiBtaW5lO1xuICB9IGVsc2Uge1xuICAgIGluZGV4LmNvbmZsaWN0ID0gdHJ1ZTtcbiAgICByZXR1cm4ge1xuICAgICAgbWluZTogbWluZSxcbiAgICAgIHRoZWlyczogdGhlaXJzXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBodW5rQmVmb3JlKHRlc3QsIGNoZWNrKSB7XG4gIHJldHVybiB0ZXN0Lm9sZFN0YXJ0IDwgY2hlY2sub2xkU3RhcnQgJiYgdGVzdC5vbGRTdGFydCArIHRlc3Qub2xkTGluZXMgPCBjaGVjay5vbGRTdGFydDtcbn1cblxuZnVuY3Rpb24gY2xvbmVIdW5rKGh1bmssIG9mZnNldCkge1xuICByZXR1cm4ge1xuICAgIG9sZFN0YXJ0OiBodW5rLm9sZFN0YXJ0LFxuICAgIG9sZExpbmVzOiBodW5rLm9sZExpbmVzLFxuICAgIG5ld1N0YXJ0OiBodW5rLm5ld1N0YXJ0ICsgb2Zmc2V0LFxuICAgIG5ld0xpbmVzOiBodW5rLm5ld0xpbmVzLFxuICAgIGxpbmVzOiBodW5rLmxpbmVzXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1lcmdlTGluZXMoaHVuaywgbWluZU9mZnNldCwgbWluZUxpbmVzLCB0aGVpck9mZnNldCwgdGhlaXJMaW5lcykge1xuICAvLyBUaGlzIHdpbGwgZ2VuZXJhbGx5IHJlc3VsdCBpbiBhIGNvbmZsaWN0ZWQgaHVuaywgYnV0IHRoZXJlIGFyZSBjYXNlcyB3aGVyZSB0aGUgY29udGV4dFxuICAvLyBpcyB0aGUgb25seSBvdmVybGFwIHdoZXJlIHdlIGNhbiBzdWNjZXNzZnVsbHkgbWVyZ2UgdGhlIGNvbnRlbnQgaGVyZS5cbiAgdmFyIG1pbmUgPSB7XG4gICAgb2Zmc2V0OiBtaW5lT2Zmc2V0LFxuICAgIGxpbmVzOiBtaW5lTGluZXMsXG4gICAgaW5kZXg6IDBcbiAgfSxcbiAgICAgIHRoZWlyID0ge1xuICAgIG9mZnNldDogdGhlaXJPZmZzZXQsXG4gICAgbGluZXM6IHRoZWlyTGluZXMsXG4gICAgaW5kZXg6IDBcbiAgfTsgLy8gSGFuZGxlIGFueSBsZWFkaW5nIGNvbnRlbnRcblxuICBpbnNlcnRMZWFkaW5nKGh1bmssIG1pbmUsIHRoZWlyKTtcbiAgaW5zZXJ0TGVhZGluZyhodW5rLCB0aGVpciwgbWluZSk7IC8vIE5vdyBpbiB0aGUgb3ZlcmxhcCBjb250ZW50LiBTY2FuIHRocm91Z2ggYW5kIHNlbGVjdCB0aGUgYmVzdCBjaGFuZ2VzIGZyb20gZWFjaC5cblxuICB3aGlsZSAobWluZS5pbmRleCA8IG1pbmUubGluZXMubGVuZ3RoICYmIHRoZWlyLmluZGV4IDwgdGhlaXIubGluZXMubGVuZ3RoKSB7XG4gICAgdmFyIG1pbmVDdXJyZW50ID0gbWluZS5saW5lc1ttaW5lLmluZGV4XSxcbiAgICAgICAgdGhlaXJDdXJyZW50ID0gdGhlaXIubGluZXNbdGhlaXIuaW5kZXhdO1xuXG4gICAgaWYgKChtaW5lQ3VycmVudFswXSA9PT0gJy0nIHx8IG1pbmVDdXJyZW50WzBdID09PSAnKycpICYmICh0aGVpckN1cnJlbnRbMF0gPT09ICctJyB8fCB0aGVpckN1cnJlbnRbMF0gPT09ICcrJykpIHtcbiAgICAgIC8vIEJvdGggbW9kaWZpZWQgLi4uXG4gICAgICBtdXR1YWxDaGFuZ2UoaHVuaywgbWluZSwgdGhlaXIpO1xuICAgIH0gZWxzZSBpZiAobWluZUN1cnJlbnRbMF0gPT09ICcrJyAmJiB0aGVpckN1cnJlbnRbMF0gPT09ICcgJykge1xuICAgICAgdmFyIF9odW5rJGxpbmVzO1xuXG4gICAgICAvLyBNaW5lIGluc2VydGVkXG4gICAgICAoX2h1bmskbGluZXMgPSBodW5rLmxpbmVzKS5wdXNoLmFwcGx5KF9odW5rJGxpbmVzLCBfdG9Db25zdW1hYmxlQXJyYXkoY29sbGVjdENoYW5nZShtaW5lKSkpO1xuICAgIH0gZWxzZSBpZiAodGhlaXJDdXJyZW50WzBdID09PSAnKycgJiYgbWluZUN1cnJlbnRbMF0gPT09ICcgJykge1xuICAgICAgdmFyIF9odW5rJGxpbmVzMjtcblxuICAgICAgLy8gVGhlaXJzIGluc2VydGVkXG4gICAgICAoX2h1bmskbGluZXMyID0gaHVuay5saW5lcykucHVzaC5hcHBseShfaHVuayRsaW5lczIsIF90b0NvbnN1bWFibGVBcnJheShjb2xsZWN0Q2hhbmdlKHRoZWlyKSkpO1xuICAgIH0gZWxzZSBpZiAobWluZUN1cnJlbnRbMF0gPT09ICctJyAmJiB0aGVpckN1cnJlbnRbMF0gPT09ICcgJykge1xuICAgICAgLy8gTWluZSByZW1vdmVkIG9yIGVkaXRlZFxuICAgICAgcmVtb3ZhbChodW5rLCBtaW5lLCB0aGVpcik7XG4gICAgfSBlbHNlIGlmICh0aGVpckN1cnJlbnRbMF0gPT09ICctJyAmJiBtaW5lQ3VycmVudFswXSA9PT0gJyAnKSB7XG4gICAgICAvLyBUaGVpciByZW1vdmVkIG9yIGVkaXRlZFxuICAgICAgcmVtb3ZhbChodW5rLCB0aGVpciwgbWluZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChtaW5lQ3VycmVudCA9PT0gdGhlaXJDdXJyZW50KSB7XG4gICAgICAvLyBDb250ZXh0IGlkZW50aXR5XG4gICAgICBodW5rLmxpbmVzLnB1c2gobWluZUN1cnJlbnQpO1xuICAgICAgbWluZS5pbmRleCsrO1xuICAgICAgdGhlaXIuaW5kZXgrKztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29udGV4dCBtaXNtYXRjaFxuICAgICAgY29uZmxpY3QoaHVuaywgY29sbGVjdENoYW5nZShtaW5lKSwgY29sbGVjdENoYW5nZSh0aGVpcikpO1xuICAgIH1cbiAgfSAvLyBOb3cgcHVzaCBhbnl0aGluZyB0aGF0IG1heSBiZSByZW1haW5pbmdcblxuXG4gIGluc2VydFRyYWlsaW5nKGh1bmssIG1pbmUpO1xuICBpbnNlcnRUcmFpbGluZyhodW5rLCB0aGVpcik7XG4gIGNhbGNMaW5lQ291bnQoaHVuayk7XG59XG5cbmZ1bmN0aW9uIG11dHVhbENoYW5nZShodW5rLCBtaW5lLCB0aGVpcikge1xuICB2YXIgbXlDaGFuZ2VzID0gY29sbGVjdENoYW5nZShtaW5lKSxcbiAgICAgIHRoZWlyQ2hhbmdlcyA9IGNvbGxlY3RDaGFuZ2UodGhlaXIpO1xuXG4gIGlmIChhbGxSZW1vdmVzKG15Q2hhbmdlcykgJiYgYWxsUmVtb3Zlcyh0aGVpckNoYW5nZXMpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciByZW1vdmUgY2hhbmdlcyB0aGF0IGFyZSBzdXBlcnNldHMgb2Ygb25lIGFub3RoZXJcbiAgICBpZiAoYXJyYXlTdGFydHNXaXRoKG15Q2hhbmdlcywgdGhlaXJDaGFuZ2VzKSAmJiBza2lwUmVtb3ZlU3VwZXJzZXQodGhlaXIsIG15Q2hhbmdlcywgbXlDaGFuZ2VzLmxlbmd0aCAtIHRoZWlyQ2hhbmdlcy5sZW5ndGgpKSB7XG4gICAgICB2YXIgX2h1bmskbGluZXMzO1xuXG4gICAgICAoX2h1bmskbGluZXMzID0gaHVuay5saW5lcykucHVzaC5hcHBseShfaHVuayRsaW5lczMsIF90b0NvbnN1bWFibGVBcnJheShteUNoYW5nZXMpKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoYXJyYXlTdGFydHNXaXRoKHRoZWlyQ2hhbmdlcywgbXlDaGFuZ2VzKSAmJiBza2lwUmVtb3ZlU3VwZXJzZXQobWluZSwgdGhlaXJDaGFuZ2VzLCB0aGVpckNoYW5nZXMubGVuZ3RoIC0gbXlDaGFuZ2VzLmxlbmd0aCkpIHtcbiAgICAgIHZhciBfaHVuayRsaW5lczQ7XG5cbiAgICAgIChfaHVuayRsaW5lczQgPSBodW5rLmxpbmVzKS5wdXNoLmFwcGx5KF9odW5rJGxpbmVzNCwgX3RvQ29uc3VtYWJsZUFycmF5KHRoZWlyQ2hhbmdlcykpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGVsc2UgaWYgKGFycmF5RXF1YWwobXlDaGFuZ2VzLCB0aGVpckNoYW5nZXMpKSB7XG4gICAgdmFyIF9odW5rJGxpbmVzNTtcblxuICAgIChfaHVuayRsaW5lczUgPSBodW5rLmxpbmVzKS5wdXNoLmFwcGx5KF9odW5rJGxpbmVzNSwgX3RvQ29uc3VtYWJsZUFycmF5KG15Q2hhbmdlcykpO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uZmxpY3QoaHVuaywgbXlDaGFuZ2VzLCB0aGVpckNoYW5nZXMpO1xufVxuXG5mdW5jdGlvbiByZW1vdmFsKGh1bmssIG1pbmUsIHRoZWlyLCBzd2FwKSB7XG4gIHZhciBteUNoYW5nZXMgPSBjb2xsZWN0Q2hhbmdlKG1pbmUpLFxuICAgICAgdGhlaXJDaGFuZ2VzID0gY29sbGVjdENvbnRleHQodGhlaXIsIG15Q2hhbmdlcyk7XG5cbiAgaWYgKHRoZWlyQ2hhbmdlcy5tZXJnZWQpIHtcbiAgICB2YXIgX2h1bmskbGluZXM2O1xuXG4gICAgKF9odW5rJGxpbmVzNiA9IGh1bmsubGluZXMpLnB1c2guYXBwbHkoX2h1bmskbGluZXM2LCBfdG9Db25zdW1hYmxlQXJyYXkodGhlaXJDaGFuZ2VzLm1lcmdlZCkpO1xuICB9IGVsc2Uge1xuICAgIGNvbmZsaWN0KGh1bmssIHN3YXAgPyB0aGVpckNoYW5nZXMgOiBteUNoYW5nZXMsIHN3YXAgPyBteUNoYW5nZXMgOiB0aGVpckNoYW5nZXMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbmZsaWN0KGh1bmssIG1pbmUsIHRoZWlyKSB7XG4gIGh1bmsuY29uZmxpY3QgPSB0cnVlO1xuICBodW5rLmxpbmVzLnB1c2goe1xuICAgIGNvbmZsaWN0OiB0cnVlLFxuICAgIG1pbmU6IG1pbmUsXG4gICAgdGhlaXJzOiB0aGVpclxuICB9KTtcbn1cblxuZnVuY3Rpb24gaW5zZXJ0TGVhZGluZyhodW5rLCBpbnNlcnQsIHRoZWlyKSB7XG4gIHdoaWxlIChpbnNlcnQub2Zmc2V0IDwgdGhlaXIub2Zmc2V0ICYmIGluc2VydC5pbmRleCA8IGluc2VydC5saW5lcy5sZW5ndGgpIHtcbiAgICB2YXIgbGluZSA9IGluc2VydC5saW5lc1tpbnNlcnQuaW5kZXgrK107XG4gICAgaHVuay5saW5lcy5wdXNoKGxpbmUpO1xuICAgIGluc2VydC5vZmZzZXQrKztcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnNlcnRUcmFpbGluZyhodW5rLCBpbnNlcnQpIHtcbiAgd2hpbGUgKGluc2VydC5pbmRleCA8IGluc2VydC5saW5lcy5sZW5ndGgpIHtcbiAgICB2YXIgbGluZSA9IGluc2VydC5saW5lc1tpbnNlcnQuaW5kZXgrK107XG4gICAgaHVuay5saW5lcy5wdXNoKGxpbmUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbGxlY3RDaGFuZ2Uoc3RhdGUpIHtcbiAgdmFyIHJldCA9IFtdLFxuICAgICAgb3BlcmF0aW9uID0gc3RhdGUubGluZXNbc3RhdGUuaW5kZXhdWzBdO1xuXG4gIHdoaWxlIChzdGF0ZS5pbmRleCA8IHN0YXRlLmxpbmVzLmxlbmd0aCkge1xuICAgIHZhciBsaW5lID0gc3RhdGUubGluZXNbc3RhdGUuaW5kZXhdOyAvLyBHcm91cCBhZGRpdGlvbnMgdGhhdCBhcmUgaW1tZWRpYXRlbHkgYWZ0ZXIgc3VidHJhY3Rpb25zIGFuZCB0cmVhdCB0aGVtIGFzIG9uZSBcImF0b21pY1wiIG1vZGlmeSBjaGFuZ2UuXG5cbiAgICBpZiAob3BlcmF0aW9uID09PSAnLScgJiYgbGluZVswXSA9PT0gJysnKSB7XG4gICAgICBvcGVyYXRpb24gPSAnKyc7XG4gICAgfVxuXG4gICAgaWYgKG9wZXJhdGlvbiA9PT0gbGluZVswXSkge1xuICAgICAgcmV0LnB1c2gobGluZSk7XG4gICAgICBzdGF0ZS5pbmRleCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBjb2xsZWN0Q29udGV4dChzdGF0ZSwgbWF0Y2hDaGFuZ2VzKSB7XG4gIHZhciBjaGFuZ2VzID0gW10sXG4gICAgICBtZXJnZWQgPSBbXSxcbiAgICAgIG1hdGNoSW5kZXggPSAwLFxuICAgICAgY29udGV4dENoYW5nZXMgPSBmYWxzZSxcbiAgICAgIGNvbmZsaWN0ZWQgPSBmYWxzZTtcblxuICB3aGlsZSAobWF0Y2hJbmRleCA8IG1hdGNoQ2hhbmdlcy5sZW5ndGggJiYgc3RhdGUuaW5kZXggPCBzdGF0ZS5saW5lcy5sZW5ndGgpIHtcbiAgICB2YXIgY2hhbmdlID0gc3RhdGUubGluZXNbc3RhdGUuaW5kZXhdLFxuICAgICAgICBtYXRjaCA9IG1hdGNoQ2hhbmdlc1ttYXRjaEluZGV4XTsgLy8gT25jZSB3ZSd2ZSBoaXQgb3VyIGFkZCwgdGhlbiB3ZSBhcmUgZG9uZVxuXG4gICAgaWYgKG1hdGNoWzBdID09PSAnKycpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNvbnRleHRDaGFuZ2VzID0gY29udGV4dENoYW5nZXMgfHwgY2hhbmdlWzBdICE9PSAnICc7XG4gICAgbWVyZ2VkLnB1c2gobWF0Y2gpO1xuICAgIG1hdGNoSW5kZXgrKzsgLy8gQ29uc3VtZSBhbnkgYWRkaXRpb25zIGluIHRoZSBvdGhlciBibG9jayBhcyBhIGNvbmZsaWN0IHRvIGF0dGVtcHRcbiAgICAvLyB0byBwdWxsIGluIHRoZSByZW1haW5pbmcgY29udGV4dCBhZnRlciB0aGlzXG5cbiAgICBpZiAoY2hhbmdlWzBdID09PSAnKycpIHtcbiAgICAgIGNvbmZsaWN0ZWQgPSB0cnVlO1xuXG4gICAgICB3aGlsZSAoY2hhbmdlWzBdID09PSAnKycpIHtcbiAgICAgICAgY2hhbmdlcy5wdXNoKGNoYW5nZSk7XG4gICAgICAgIGNoYW5nZSA9IHN0YXRlLmxpbmVzWysrc3RhdGUuaW5kZXhdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtYXRjaC5zdWJzdHIoMSkgPT09IGNoYW5nZS5zdWJzdHIoMSkpIHtcbiAgICAgIGNoYW5nZXMucHVzaChjaGFuZ2UpO1xuICAgICAgc3RhdGUuaW5kZXgrKztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uZmxpY3RlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKChtYXRjaENoYW5nZXNbbWF0Y2hJbmRleF0gfHwgJycpWzBdID09PSAnKycgJiYgY29udGV4dENoYW5nZXMpIHtcbiAgICBjb25mbGljdGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChjb25mbGljdGVkKSB7XG4gICAgcmV0dXJuIGNoYW5nZXM7XG4gIH1cblxuICB3aGlsZSAobWF0Y2hJbmRleCA8IG1hdGNoQ2hhbmdlcy5sZW5ndGgpIHtcbiAgICBtZXJnZWQucHVzaChtYXRjaENoYW5nZXNbbWF0Y2hJbmRleCsrXSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1lcmdlZDogbWVyZ2VkLFxuICAgIGNoYW5nZXM6IGNoYW5nZXNcbiAgfTtcbn1cblxuZnVuY3Rpb24gYWxsUmVtb3ZlcyhjaGFuZ2VzKSB7XG4gIHJldHVybiBjaGFuZ2VzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY2hhbmdlKSB7XG4gICAgcmV0dXJuIHByZXYgJiYgY2hhbmdlWzBdID09PSAnLSc7XG4gIH0sIHRydWUpO1xufVxuXG5mdW5jdGlvbiBza2lwUmVtb3ZlU3VwZXJzZXQoc3RhdGUsIHJlbW92ZUNoYW5nZXMsIGRlbHRhKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsdGE7IGkrKykge1xuICAgIHZhciBjaGFuZ2VDb250ZW50ID0gcmVtb3ZlQ2hhbmdlc1tyZW1vdmVDaGFuZ2VzLmxlbmd0aCAtIGRlbHRhICsgaV0uc3Vic3RyKDEpO1xuXG4gICAgaWYgKHN0YXRlLmxpbmVzW3N0YXRlLmluZGV4ICsgaV0gIT09ICcgJyArIGNoYW5nZUNvbnRlbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5pbmRleCArPSBkZWx0YTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNhbGNPbGROZXdMaW5lQ291bnQobGluZXMpIHtcbiAgdmFyIG9sZExpbmVzID0gMDtcbiAgdmFyIG5ld0xpbmVzID0gMDtcbiAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgIGlmICh0eXBlb2YgbGluZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBteUNvdW50ID0gY2FsY09sZE5ld0xpbmVDb3VudChsaW5lLm1pbmUpO1xuICAgICAgdmFyIHRoZWlyQ291bnQgPSBjYWxjT2xkTmV3TGluZUNvdW50KGxpbmUudGhlaXJzKTtcblxuICAgICAgaWYgKG9sZExpbmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG15Q291bnQub2xkTGluZXMgPT09IHRoZWlyQ291bnQub2xkTGluZXMpIHtcbiAgICAgICAgICBvbGRMaW5lcyArPSBteUNvdW50Lm9sZExpbmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9sZExpbmVzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdMaW5lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChteUNvdW50Lm5ld0xpbmVzID09PSB0aGVpckNvdW50Lm5ld0xpbmVzKSB7XG4gICAgICAgICAgbmV3TGluZXMgKz0gbXlDb3VudC5uZXdMaW5lcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdMaW5lcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmV3TGluZXMgIT09IHVuZGVmaW5lZCAmJiAobGluZVswXSA9PT0gJysnIHx8IGxpbmVbMF0gPT09ICcgJykpIHtcbiAgICAgICAgbmV3TGluZXMrKztcbiAgICAgIH1cblxuICAgICAgaWYgKG9sZExpbmVzICE9PSB1bmRlZmluZWQgJiYgKGxpbmVbMF0gPT09ICctJyB8fCBsaW5lWzBdID09PSAnICcpKSB7XG4gICAgICAgIG9sZExpbmVzKys7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBvbGRMaW5lczogb2xkTGluZXMsXG4gICAgbmV3TGluZXM6IG5ld0xpbmVzXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJldmVyc2VQYXRjaChzdHJ1Y3R1cmVkUGF0Y2gpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RydWN0dXJlZFBhdGNoKSkge1xuICAgIHJldHVybiBzdHJ1Y3R1cmVkUGF0Y2gubWFwKHJldmVyc2VQYXRjaCkucmV2ZXJzZSgpO1xuICB9XG5cbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBzdHJ1Y3R1cmVkUGF0Y2gpLCB7fSwge1xuICAgIG9sZEZpbGVOYW1lOiBzdHJ1Y3R1cmVkUGF0Y2gubmV3RmlsZU5hbWUsXG4gICAgb2xkSGVhZGVyOiBzdHJ1Y3R1cmVkUGF0Y2gubmV3SGVhZGVyLFxuICAgIG5ld0ZpbGVOYW1lOiBzdHJ1Y3R1cmVkUGF0Y2gub2xkRmlsZU5hbWUsXG4gICAgbmV3SGVhZGVyOiBzdHJ1Y3R1cmVkUGF0Y2gub2xkSGVhZGVyLFxuICAgIGh1bmtzOiBzdHJ1Y3R1cmVkUGF0Y2guaHVua3MubWFwKGZ1bmN0aW9uIChodW5rKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvbGRMaW5lczogaHVuay5uZXdMaW5lcyxcbiAgICAgICAgb2xkU3RhcnQ6IGh1bmsubmV3U3RhcnQsXG4gICAgICAgIG5ld0xpbmVzOiBodW5rLm9sZExpbmVzLFxuICAgICAgICBuZXdTdGFydDogaHVuay5vbGRTdGFydCxcbiAgICAgICAgbGluZWRlbGltaXRlcnM6IGh1bmsubGluZWRlbGltaXRlcnMsXG4gICAgICAgIGxpbmVzOiBodW5rLmxpbmVzLm1hcChmdW5jdGlvbiAobCkge1xuICAgICAgICAgIGlmIChsLnN0YXJ0c1dpdGgoJy0nKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiK1wiLmNvbmNhdChsLnNsaWNlKDEpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobC5zdGFydHNXaXRoKCcrJykpIHtcbiAgICAgICAgICAgIHJldHVybiBcIi1cIi5jb25jYXQobC5zbGljZSgxKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGw7XG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH0pXG4gIH0pO1xufVxuXG4vLyBTZWU6IGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9nb29nbGUtZGlmZi1tYXRjaC1wYXRjaC93aWtpL0FQSVxuZnVuY3Rpb24gY29udmVydENoYW5nZXNUb0RNUChjaGFuZ2VzKSB7XG4gIHZhciByZXQgPSBbXSxcbiAgICAgIGNoYW5nZSxcbiAgICAgIG9wZXJhdGlvbjtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjaGFuZ2UgPSBjaGFuZ2VzW2ldO1xuXG4gICAgaWYgKGNoYW5nZS5hZGRlZCkge1xuICAgICAgb3BlcmF0aW9uID0gMTtcbiAgICB9IGVsc2UgaWYgKGNoYW5nZS5yZW1vdmVkKSB7XG4gICAgICBvcGVyYXRpb24gPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3BlcmF0aW9uID0gMDtcbiAgICB9XG5cbiAgICByZXQucHVzaChbb3BlcmF0aW9uLCBjaGFuZ2UudmFsdWVdKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRDaGFuZ2VzVG9YTUwoY2hhbmdlcykge1xuICB2YXIgcmV0ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNoYW5nZSA9IGNoYW5nZXNbaV07XG5cbiAgICBpZiAoY2hhbmdlLmFkZGVkKSB7XG4gICAgICByZXQucHVzaCgnPGlucz4nKTtcbiAgICB9IGVsc2UgaWYgKGNoYW5nZS5yZW1vdmVkKSB7XG4gICAgICByZXQucHVzaCgnPGRlbD4nKTtcbiAgICB9XG5cbiAgICByZXQucHVzaChlc2NhcGVIVE1MKGNoYW5nZS52YWx1ZSkpO1xuXG4gICAgaWYgKGNoYW5nZS5hZGRlZCkge1xuICAgICAgcmV0LnB1c2goJzwvaW5zPicpO1xuICAgIH0gZWxzZSBpZiAoY2hhbmdlLnJlbW92ZWQpIHtcbiAgICAgIHJldC5wdXNoKCc8L2RlbD4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0LmpvaW4oJycpO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVIVE1MKHMpIHtcbiAgdmFyIG4gPSBzO1xuICBuID0gbi5yZXBsYWNlKC8mL2csICcmYW1wOycpO1xuICBuID0gbi5yZXBsYWNlKC88L2csICcmbHQ7Jyk7XG4gIG4gPSBuLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcbiAgbiA9IG4ucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xuICByZXR1cm4gbjtcbn1cblxuZXhwb3J0IHsgRGlmZiwgYXBwbHlQYXRjaCwgYXBwbHlQYXRjaGVzLCBjYW5vbmljYWxpemUsIGNvbnZlcnRDaGFuZ2VzVG9ETVAsIGNvbnZlcnRDaGFuZ2VzVG9YTUwsIGNyZWF0ZVBhdGNoLCBjcmVhdGVUd29GaWxlc1BhdGNoLCBkaWZmQXJyYXlzLCBkaWZmQ2hhcnMsIGRpZmZDc3MsIGRpZmZKc29uLCBkaWZmTGluZXMsIGRpZmZTZW50ZW5jZXMsIGRpZmZUcmltbWVkTGluZXMsIGRpZmZXb3JkcywgZGlmZldvcmRzV2l0aFNwYWNlLCBmb3JtYXRQYXRjaCwgbWVyZ2UsIHBhcnNlUGF0Y2gsIHJldmVyc2VQYXRjaCwgc3RydWN0dXJlZFBhdGNoIH07XG4iXSwibmFtZXMiOlsiRGlmZiIsInByb3RvdHlwZSIsImRpZmYiLCJvbGRTdHJpbmciLCJuZXdTdHJpbmciLCJfb3B0aW9ucyR0aW1lb3V0Iiwib3B0aW9ucyIsImFyZ3VtZW50cyIsImxlbmd0aCIsInVuZGVmaW5lZCIsImNhbGxiYWNrIiwic2VsZiIsImRvbmUiLCJ2YWx1ZSIsInNldFRpbWVvdXQiLCJjYXN0SW5wdXQiLCJyZW1vdmVFbXB0eSIsInRva2VuaXplIiwibmV3TGVuIiwib2xkTGVuIiwiZWRpdExlbmd0aCIsIm1heEVkaXRMZW5ndGgiLCJNYXRoIiwibWluIiwibWF4RXhlY3V0aW9uVGltZSIsInRpbWVvdXQiLCJJbmZpbml0eSIsImFib3J0QWZ0ZXJUaW1lc3RhbXAiLCJEYXRlIiwibm93IiwiYmVzdFBhdGgiLCJvbGRQb3MiLCJsYXN0Q29tcG9uZW50IiwibmV3UG9zIiwiZXh0cmFjdENvbW1vbiIsImpvaW4iLCJjb3VudCIsIm1pbkRpYWdvbmFsVG9Db25zaWRlciIsIm1heERpYWdvbmFsVG9Db25zaWRlciIsImV4ZWNFZGl0TGVuZ3RoIiwiZGlhZ29uYWxQYXRoIiwibWF4IiwiYmFzZVBhdGgiLCJyZW1vdmVQYXRoIiwiYWRkUGF0aCIsImNhbkFkZCIsImFkZFBhdGhOZXdQb3MiLCJjYW5SZW1vdmUiLCJhZGRUb1BhdGgiLCJidWlsZFZhbHVlcyIsInVzZUxvbmdlc3RUb2tlbiIsImV4ZWMiLCJyZXQiLCJwYXRoIiwiYWRkZWQiLCJyZW1vdmVkIiwib2xkUG9zSW5jIiwibGFzdCIsInByZXZpb3VzQ29tcG9uZW50IiwiY29tbW9uQ291bnQiLCJlcXVhbHMiLCJsZWZ0IiwicmlnaHQiLCJjb21wYXJhdG9yIiwiaWdub3JlQ2FzZSIsInRvTG93ZXJDYXNlIiwiYXJyYXkiLCJpIiwicHVzaCIsInNwbGl0IiwiY2hhcnMiLCJjb21wb25lbnRzIiwibmV4dENvbXBvbmVudCIsInJldmVyc2UiLCJjb21wb25lbnRQb3MiLCJjb21wb25lbnRMZW4iLCJjb21wb25lbnQiLCJzbGljZSIsIm1hcCIsIm9sZFZhbHVlIiwidG1wIiwiZmluYWxDb21wb25lbnQiLCJwb3AiLCJjaGFyYWN0ZXJEaWZmIiwiZGlmZkNoYXJzIiwib2xkU3RyIiwibmV3U3RyIiwiZ2VuZXJhdGVPcHRpb25zIiwiZGVmYXVsdHMiLCJuYW1lIiwiaGFzT3duUHJvcGVydHkiLCJleHRlbmRlZFdvcmRDaGFycyIsInJlV2hpdGVzcGFjZSIsIndvcmREaWZmIiwiaWdub3JlV2hpdGVzcGFjZSIsInRlc3QiLCJ0b2tlbnMiLCJzcGxpY2UiLCJkaWZmV29yZHMiLCJkaWZmV29yZHNXaXRoU3BhY2UiLCJsaW5lRGlmZiIsInN0cmlwVHJhaWxpbmdDciIsInJlcGxhY2UiLCJyZXRMaW5lcyIsImxpbmVzQW5kTmV3bGluZXMiLCJsaW5lIiwibmV3bGluZUlzVG9rZW4iLCJ0cmltIiwiZGlmZkxpbmVzIiwiZGlmZlRyaW1tZWRMaW5lcyIsInNlbnRlbmNlRGlmZiIsImRpZmZTZW50ZW5jZXMiLCJjc3NEaWZmIiwiZGlmZkNzcyIsIl90eXBlb2YiLCJvYmoiLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwiX2RlZmluZVByb3BlcnR5Iiwia2V5IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJvd25LZXlzIiwib2JqZWN0IiwiZW51bWVyYWJsZU9ubHkiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic3ltYm9scyIsImZpbHRlciIsInN5bSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImFwcGx5IiwiX29iamVjdFNwcmVhZDIiLCJ0YXJnZXQiLCJzb3VyY2UiLCJmb3JFYWNoIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJfaXRlcmFibGVUb0FycmF5IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlU3ByZWFkIiwiQXJyYXkiLCJpc0FycmF5IiwiX2FycmF5TGlrZVRvQXJyYXkiLCJpdGVyIiwiZnJvbSIsIm8iLCJtaW5MZW4iLCJuIiwidG9TdHJpbmciLCJjYWxsIiwibGVuIiwiYXJyMiIsIlR5cGVFcnJvciIsIm9iamVjdFByb3RvdHlwZVRvU3RyaW5nIiwianNvbkRpZmYiLCJfdGhpcyRvcHRpb25zIiwidW5kZWZpbmVkUmVwbGFjZW1lbnQiLCJfdGhpcyRvcHRpb25zJHN0cmluZ2kiLCJzdHJpbmdpZnlSZXBsYWNlciIsImsiLCJ2IiwiSlNPTiIsInN0cmluZ2lmeSIsImNhbm9uaWNhbGl6ZSIsImRpZmZKc29uIiwib2xkT2JqIiwibmV3T2JqIiwic3RhY2siLCJyZXBsYWNlbWVudFN0YWNrIiwicmVwbGFjZXIiLCJjYW5vbmljYWxpemVkT2JqIiwidG9KU09OIiwic29ydGVkS2V5cyIsIl9rZXkiLCJzb3J0IiwiYXJyYXlEaWZmIiwiZGlmZkFycmF5cyIsIm9sZEFyciIsIm5ld0FyciIsInBhcnNlUGF0Y2giLCJ1bmlEaWZmIiwiZGlmZnN0ciIsImRlbGltaXRlcnMiLCJtYXRjaCIsImxpc3QiLCJwYXJzZUluZGV4IiwiaW5kZXgiLCJoZWFkZXIiLCJwYXJzZUZpbGVIZWFkZXIiLCJodW5rcyIsIl9saW5lIiwicGFyc2VIdW5rIiwic3RyaWN0IiwiRXJyb3IiLCJmaWxlSGVhZGVyIiwia2V5UHJlZml4IiwiZGF0YSIsImZpbGVOYW1lIiwic3Vic3RyIiwiY2h1bmtIZWFkZXJJbmRleCIsImNodW5rSGVhZGVyTGluZSIsImNodW5rSGVhZGVyIiwiaHVuayIsIm9sZFN0YXJ0Iiwib2xkTGluZXMiLCJuZXdTdGFydCIsIm5ld0xpbmVzIiwibGluZXMiLCJsaW5lZGVsaW1pdGVycyIsImFkZENvdW50IiwicmVtb3ZlQ291bnQiLCJpbmRleE9mIiwib3BlcmF0aW9uIiwiZGlzdGFuY2VJdGVyYXRvciIsInN0YXJ0IiwibWluTGluZSIsIm1heExpbmUiLCJ3YW50Rm9yd2FyZCIsImJhY2t3YXJkRXhoYXVzdGVkIiwiZm9yd2FyZEV4aGF1c3RlZCIsImxvY2FsT2Zmc2V0IiwiYXBwbHlQYXRjaCIsImNvbXBhcmVMaW5lIiwibGluZU51bWJlciIsInBhdGNoQ29udGVudCIsImVycm9yQ291bnQiLCJmdXp6RmFjdG9yIiwib2Zmc2V0IiwicmVtb3ZlRU9GTkwiLCJhZGRFT0ZOTCIsImh1bmtGaXRzIiwidG9Qb3MiLCJqIiwiY29udGVudCIsImRpZmZPZmZzZXQiLCJfaSIsIl9odW5rIiwiX3RvUG9zIiwiZGVsaW1pdGVyIiwicHJldmlvdXNPcGVyYXRpb24iLCJfayIsImFwcGx5UGF0Y2hlcyIsImN1cnJlbnRJbmRleCIsInByb2Nlc3NJbmRleCIsImNvbXBsZXRlIiwibG9hZEZpbGUiLCJlcnIiLCJ1cGRhdGVkQ29udGVudCIsInBhdGNoZWQiLCJzdHJ1Y3R1cmVkUGF0Y2giLCJvbGRGaWxlTmFtZSIsIm5ld0ZpbGVOYW1lIiwib2xkSGVhZGVyIiwibmV3SGVhZGVyIiwiY29udGV4dCIsImNvbnRleHRMaW5lcyIsImVudHJ5Iiwib2xkUmFuZ2VTdGFydCIsIm5ld1JhbmdlU3RhcnQiLCJjdXJSYW5nZSIsIm9sZExpbmUiLCJuZXdMaW5lIiwiX2xvb3AiLCJjdXJyZW50IiwiX2N1clJhbmdlIiwicHJldiIsIl9jdXJSYW5nZTIiLCJfY3VyUmFuZ2UzIiwiY29udGV4dFNpemUiLCJvbGRFT0ZOZXdsaW5lIiwibmV3RU9GTmV3bGluZSIsIm5vTmxCZWZvcmVBZGRzIiwiZm9ybWF0UGF0Y2giLCJjcmVhdGVUd29GaWxlc1BhdGNoIiwiY3JlYXRlUGF0Y2giLCJhcnJheUVxdWFsIiwiYSIsImIiLCJhcnJheVN0YXJ0c1dpdGgiLCJjYWxjTGluZUNvdW50IiwiX2NhbGNPbGROZXdMaW5lQ291bnQiLCJjYWxjT2xkTmV3TGluZUNvdW50IiwibWVyZ2UiLCJtaW5lIiwidGhlaXJzIiwiYmFzZSIsImxvYWRQYXRjaCIsImZpbGVOYW1lQ2hhbmdlZCIsInNlbGVjdEZpZWxkIiwibWluZUluZGV4IiwidGhlaXJzSW5kZXgiLCJtaW5lT2Zmc2V0IiwidGhlaXJzT2Zmc2V0IiwibWluZUN1cnJlbnQiLCJ0aGVpcnNDdXJyZW50IiwiaHVua0JlZm9yZSIsImNsb25lSHVuayIsIm1lcmdlZEh1bmsiLCJtZXJnZUxpbmVzIiwicGFyYW0iLCJwYXRjaCIsImNvbmZsaWN0IiwiY2hlY2siLCJtaW5lTGluZXMiLCJ0aGVpck9mZnNldCIsInRoZWlyTGluZXMiLCJ0aGVpciIsImluc2VydExlYWRpbmciLCJ0aGVpckN1cnJlbnQiLCJtdXR1YWxDaGFuZ2UiLCJfaHVuayRsaW5lcyIsImNvbGxlY3RDaGFuZ2UiLCJfaHVuayRsaW5lczIiLCJyZW1vdmFsIiwiaW5zZXJ0VHJhaWxpbmciLCJteUNoYW5nZXMiLCJ0aGVpckNoYW5nZXMiLCJhbGxSZW1vdmVzIiwic2tpcFJlbW92ZVN1cGVyc2V0IiwiX2h1bmskbGluZXMzIiwiX2h1bmskbGluZXM0IiwiX2h1bmskbGluZXM1Iiwic3dhcCIsImNvbGxlY3RDb250ZXh0IiwibWVyZ2VkIiwiX2h1bmskbGluZXM2IiwiaW5zZXJ0Iiwic3RhdGUiLCJtYXRjaENoYW5nZXMiLCJjaGFuZ2VzIiwibWF0Y2hJbmRleCIsImNvbnRleHRDaGFuZ2VzIiwiY29uZmxpY3RlZCIsImNoYW5nZSIsInJlZHVjZSIsInJlbW92ZUNoYW5nZXMiLCJkZWx0YSIsImNoYW5nZUNvbnRlbnQiLCJteUNvdW50IiwidGhlaXJDb3VudCIsInJldmVyc2VQYXRjaCIsImwiLCJzdGFydHNXaXRoIiwiY29uY2F0IiwiY29udmVydENoYW5nZXNUb0RNUCIsImNvbnZlcnRDaGFuZ2VzVG9YTUwiLCJlc2NhcGVIVE1MIiwicyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/uvu/node_modules/diff/lib/index.mjs\n");

/***/ })

};
;